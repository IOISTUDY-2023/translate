# Railway Trip 2(JOI 2022)
# 문제
IOI 철도회사는 철도 선로를 운행하고 있습니다. 있다
$N$ 역은 직선으로 번호가 매겨져 있습니다.
$1$ 에
$N$. 각각
$i$ (
$1 ≤ i ≤ N - 1$), 역
$i$ 및 역
$i + 1$은 철도 선로로 직접 연결됩니다.

IOI 철도 회사가 운영 중입니다.
$M$ 라인, 번호는 다음과 같습니다.
$1$ 에
$M$. 인라인
$j$ (
$1 ≤ j ≤ M$), 출발역은 Station
$A_j$, 종착역은 Station
$B_j$. 기차는 모든 역에 정차합니다. 즉, 만약
$A_j < B_j$ 라인 열차
$j$ 역에 정차
$A_j$, 역
$A_j + 1$,
$\dots$, 역
$B_j$, 이 순서대로요. 만약에
$A_j > B_j$, Line의 열차
$j$ 역에 정차
$A_j$, 역
$A_j - 1$,
$\dots$, 역
$B_j$, 이 순서대로요.

조이군은 여행자예요. 그는 가지고있다
$Q$ 여행 계획. 에서
$k$번째 계획(
$1 ≤ k ≤ Q$), 그는 역에서 여행합니다.
$S_k$ 역까지
줄을 서서 $T_k$.

하지만 조이군은 긴 여행으로 지쳐있습니다. 그는 빈 기차를 타고 자리에 앉고 싶어합니다. 그래서 조이군은 역에서 한 노선의 열차를 타기로 결정했어요.
노선의 시작역에서 $K$번째 또는 그 이전에 정차합니다. 즉, 만약
$A_j < B_j$, 라인 열차를 탈 수 있어요
$j$는 역에서만 가능
$A_j$, 역
$A_j + 1$,
$\dots$, 역
$\min{\{A_j + K - 1, B_j - 1\}}$. 만약에
$A_j > B_j$, 라인 열차를 탈 수 있어요
$j$는 역에서만 가능
$A_j$, 역
$A_j - 1$,
$\dots$, 역
$\max{\{A_j - K + 1, B_j + 1\}}$. 조이군은 기차를 타는 옆 역과 종착역 사이의 역에서 내리게 됩니다.

이런 상황에서 조이군은 열차 탑승 횟수를 최소화하고 싶어한다.

IOI 철도 회사의 노선 정보와 JOI 군의 계획에 대한 정보를 바탕으로 JOI 군의 각 계획에 대해 JOI 군이 이를 달성하는 데 필요한 최소 열차 탑승 횟수를 계산하는 프로그램을 작성하세요.
# 입력
표준 입력에서 다음 데이터를 읽습니다.   
   
입력의 첫 번째 줄에는 세 개의 공백으로 구분된 정수 N, M, Q가 포함됩니다. 이는 비버의 N 마을과 M 운하 및 Q 파티 Bitaro가 있음을 의미합니다.   
다음 M 라인의 i 번째 라인 $(1 ≤ i ≤ M)$에는 공백으로 구분된 두 개의 정수 $S_i$ 및 $E_i$가 포함됩니다. 
이것은 운하가 $S_i$에서 $E_i$로 단방향으로 흐른다는 것을 의미합니다.   
다음 Q 행의 j번째 행 $(1 ≤ j ≤ Q)$에는 공백으로 구분된 두 정수 $T_j$ , $Y_j$ 및 $Y_j$ 공백으로 구분된 정수 $C_{j,1}, C_{j,2}, ..., C_{j,Y_j}$가 포함됩니다.    
이것은 j번째 파티가 $T_j$ 마을에서 열리고 $C_{j,1}, C_{j,2}, ...,C_{j,Y_j}$ 마을에 사는 친구들이 바쁘다는 것을 의미합니다.   
# 출력
Q개의 줄에 정수를 한 개씩 출력하십시오.   
j번째 줄 $(1 ≤ j ≤ Q)$에는 j번째 파티에서 가장 많은 수의 운하를 사용하는 참석자가 사용하는 운하의 수를 출력해야 합니다. j번째 파티에 아무도 참석할 수 없으면 j번째 줄에 -1을 출력합니다.
# 제한
$1 ≤ N ≤ 100 000.$   
$0 ≤ M ≤ 200 000.$   
$1 ≤ Q ≤ 100 000.$   
$1 ≤ S_i < E_i ≤ N (1 ≤ i ≤ M).$   
$(S_i , E_i) , (S_j , E_j) (1 ≤ i < j ≤ M).$   
$1 ≤ T_j ≤ N (1 ≤ j ≤ Q).$   
$0 ≤ Y_j ≤ N (1 ≤ j ≤ Q).$   
$1 ≤ C_{j,1} < C_{j,2} < · · · < C_{j,Y_j} ≤ N (1 ≤ j ≤ Q).$   
$Y_1 + Y_2 + · · · + Y_Q ≤ 100 000．$   
# 서브태스크
|번호|배점|제한|
|---|---|---|
|1|7|$N \le 1000, M \le 2000, Q=1$|
|2|7|$Q=1$|
|3|86|추가 제약조건이 없음|
## 예제

### 예제 입력 1
```
5 6 3
1 2
2 4
3 4
1 3
3 5
4 5
4 1 1
5 2 2 3
2 3 1 4 5
```
### 예제 출력 1
```
1
3
0
```
### 설명
첫 번째 파티에 참석한 친구들(2번 마을, 3번 마을, 4번 마을에 사는 친구들) 중 2번 마을, 3번 마을에 사는 친구들은 가장 많은 수의 운하를 통해 파티가 열리는 4번 마을로 이동합니다. 그 개수는 1이므로 1을 출력합니다.   
   
두 번째 파티에 참석한 친구들(1번 마을, 4번 마을, 5번 마을에 사는 친구들) 중에서 1번 마을에 사는 친구는 가장 많은 수의 운하를 통해 파티가 열리는 5번 마을로 이동합니다. 그 개수는 3이므로 3을 출력합니다.   
   
2번 마을에 사는 친구만이 3번째 파티에 참석합니다. 그는 운하를 사용하지 않으므로 출력은 0입니다.   
### 예제 입력 1
```
12 17 10
1 2
2 3
3 4
1 5
2 6
3 7
4 8
5 6
6 7
7 8
5 9
6 10
7 11
8 12
9 10
10 11
11 12
6 3 1 7 12
3 7 1 2 3 4 5 6 7
11 3 1 3 5
9 2 1 9
8 4 1 2 3 4
1 1 1
12 0
10 3 1 6 10
11 8 2 3 5 6 7 9 10 11
8 7 2 3 4 5 6 7 8
```
### 예제 출력 1
```
1
-1
3
1
3
-1
5
2
4
4
```
+ ## Subtask 1,2. ( $14점$)
모든 쿼리가 정확히 하나의 정점에 대해서만 진행되는 경우의 dp 입니다. 각 정점들의 최대 운하의 수를 dp값으로 들고 있는 상황을 생각해봅시다. 어차피 DAG이기 때문에 어떤 노드에서 필요한 운하의 수를 재귀적으로 파고들면 항상 dp를 적절히 계산할 수 있음을 알 수 있습니다. 따라서 주어진 상황에서 최대 운하수를 전부 계산할 수 있고, 따라서 문제를 해결할 수 있습니다.
+ ## Subtask 3. ( $86점$)
우선, 만약 $Y_i$가 굉장히 크다면, 이때는 단순히 subtask 1,2의 풀이를 바로 적용해서 $O(n+m)$정도에 문제를 해결할 수 있습니다. $Y_i$가 굉장히 큰 쿼리들에 대해 잠시 생각해보면, 그러한 쿼리들은 그렇게 많지 않다는 사실을 알 수 있습니다. 만약 $t \le Y_i$일때 $Y_i$가 "굉장히 크다"라고 한다면, 그러한 쿼리의 개수는 $Q/t$를 절대 넘을 수 없고, 따라서 이 종류의 쿼리들을 처리하는데에 드는 시간은 $O((n+m)*Q/t)$가 됩니다.   
 이제 남은 것은 $Y_i$가 충분히 작은 쿼리들입니다. 여기에서 해야하는 관찰은, 파티가 주최되는 정점으로 갈 수 있는 최대 경로의 길이를 구하는 문제는, 그래프의 방향을 완벽히 뒤집은 다음 파티가 주최되는 정점에서 도달할 수 있는 모든 정점들에 대해 그 경로의 최댓값을 구하는 문제로 바꿀 수 있다는 사실입니다. 물론, subtask 1,2의 풀이처럼 최댓값만 저장해둔다면 최댓값이 되는 정점이 바쁜 정점일 가능성이 있기 때문에 통하지 않음을 알 수 있습니다.   
 그렇다면, 만약 하나의 정점에서 갈 수 있는 정점들을 경로가 긴 순으로 $t+1$개 들고 있는 상황이라면 어떨까요? 무조건 DAG이기 때문에 자식노드들로부터 병합을 하는 것도 가능하고, 설령 해당 정점에서 알아낸 $t+1$개의 정점들중 $t$개가 다르다고 하더라도, 남아있는 나머지 하나의 정점이 최대 길이라는 사실을 자명하게 알 수 있습니다. 어떤 노드에서 두 자식노드를 융합하는데에 걸리는 시간복잡도는 두 수열을 merge하는 아이디어처럼 구현한다면 $O(t)$가 되고, 간선은 m개이기 때문에 총 시간복잡도는 $O(t(m+n))$정도가 됩니다. 하나의 쿼리를 처리하기 위해서는 역시 적절한 처리를 통해 어떤 정점이 들고 있는 $t+1$개의 정점들중 제외되는 것들을 전부 빼낸 뒤 그중 최댓값을 찾으면 되는데, 이 또한 $O(t)$에 해결할 수 있습니다.   
 결과적으로, 전체 문제를 $(O(t(m+n)+(m+n)*Q/t))$만에 해결할 수 있는데, 이는 $t=sqrt(Q)$로 둘 경우 $O((m+n)sqrt(Q))$가 되어 문제를 해결하기에 충분해집니다.
