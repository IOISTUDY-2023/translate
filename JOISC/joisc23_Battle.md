# The Last Battle(joisc 2023)
# 문제
JOICup은 JOI 방송국에서 진행하는 인기 TV 버라이어티 프로그램입니다. 이제 JOICup은 최종국면으로 접어들었습니다. 마지막 라운드에서는 '메신저 게임'이 진행됩니다. 
첫 라운드를 통과한 한 팀만 게임에 참여하게 됩니다. 팀은 안나(Anna)와 브루노(Bruno) 두 명의 플레이어로 구성되어 있습니다.

메신저 게임에서 플레이어는 $8 \times 8$ 격자판을 사용하여 정보를 보냅니다.
격자판의 행과 열은 0부터 7까지 숫자가 매겨져 있습니다.

메신저 게임에서 안나와 브루노는 서로 다른 방에 고립되어 있습니다. 그들은 총 Q회의 도전을 할 것입니다. 
i번째 도전(1<=i<=Q)은 다음과 같이 진행됩니다.

1. 게임 진행자인 비타로가 카드와 $8 \times 8$ 격자판을 Anna에게 줍니다.
$8 \times 8$ 셀을 Anna에게 보냅니다. 카드에는 세 정수 X_i,Y_i,N_i(0<=X_i<=7,0<=Y_i<=7,1<=N_i<=43)
'A','B'로 구성된 길이 N_i의 문자열 S_i가 적혀있습니다. 그리드의 모든 셀은 흰색입니다.
2. 안나는 X_i행에도 포함되지 않고, Y_i열에도 포함되지 않는 49개의 칸들을 색칠합니다.
각 칸들의 색상은 파란색이거나, 빨간색입니다.
3. Anna는 게임 진행자인 Bitaro에게 셀 그리드를 제공합니다.
4. 비타로는 X_i행에 포함되어있거나, Y_i열에 포함되어있는 총 15개의 칸들을 색칠한다.
각 칸들의 색상은 파란색이거나, 빨간색입니다. 이 과정은 Anna나 Bruno가 볼 수 없는 방에서 진행됩니다.
5. 게임 진행자인 비타로는 브루노에게 카드와 격자판을 줍니다. 카드에는 오직 N_i만이 적혀있습니다.
6. 브루노는 종이에 문자열을 씁니다. 이 문자열이 S_i와 같다면, Anna와 Bruno는 게임에서 승리합니다.
다음 그림과 같이 챌린지가 진행됩니다.

Anna와 Bruno가 "메신저 게임"에서 승리하기 위한 전략을 구현하는 프로그램을 작성하십시오. 
이 문제의 그레이딩을 위해, 그레이딩을 보십시오.
# 구현
두 개의 파일을 제출해야 합니다.

첫 번째 파일은 Anna.cpp입니다. Anna의 전략을 구현해야 합니다. 다음 기능을 구현해야 합니다. 프로그램은 전처리 지시문 #include를 사용하여 Anna.h를 포함해야 합니다.

void Anna(int X, int Y, int N, std::string S)
이 함수는 총 $Q$번 호출됩니다.
$i$번째 호출(
$1 ≤ i ≤ Q$)은 각각 $i$번째 도전의 1,2,3번째 절차에 해당합니다.

매개변수 X는 $i$번째 도전의 절차 1.에서 Anna에게 주어진 카드에 적혀있는 정수 $X_i$입니다.
매개변수 Y는 $i$번째 도전의 절차 1.에서 Anna에게 주어진 카드에 적혀있는 정수 $Y_i$입니다.
매개변수 N는 $i$번째 도전의 절차 1.에서 Anna에게 주어진 카드에 적혀있는 정수 $N_i$입니다.
매개변수 S는 $i$번째 도전의 절차 1.에서 Anna에게 주어진 카드에 적혀있는 문자열 $S_i$입니다.
 Anna 함수의 호출마다, 다음의 함수가 도합 49번 호출되어야 합니다. 해당 함수는 행이 $X_i$와 다르고 열이 $Y_i$와 다른 49개의 칸들에 대해 각각 한번씩 호출되어야 합니다.

void Paint(int a, int b, int c)
매개변수 a, b는 Anna가 행이 a이고 열이 b인 셀을 칠한다는 것을 의미합니다. 여기서
$0 ≤ a ≤ 7$,
$0 ≤ b ≤ 7$, a ≠ X, b ≠ Y가 만족되어야 합니다. 이 조건이 만족되지 않으면 귀하의 프로그램은 오답[1]으로 판단됩니다.
매개변수 c는 Anna가 칠한 색상이 c = 0이면 파란색이고, c = 1이면 빨간색임을 의미합니다. 여기서,
$0 ≤ c ≤ 1$이 만족되어야 합니다. 이 조건이 만족되지 않으면 귀하의 프로그램은 오답[2]으로 판단됩니다.
동일한 매개변수(a, b)를 사용하여 Paint 함수를 두 번 이상 호출하면 해당 프로그램은 오답[3]으로 판단됩니다.
Anna 함수가 종료될 때 Paint에 대한 함수 호출 횟수가 $49$가 아닌 경우
, 귀하의 프로그램은 오답[4]으로 판단됩니다.

두 번째 파일은 Bruno.cpp입니다. Bruno의 전략을 실행해야 합니다. 다음 기능을 구현해야 합니다. 프로그램은 전처리 지시문 #include를 사용하여 Bruno.h를 포함해야 합니다.

std::string Bruno(int N, std::vector<std::vector<int>> T)
이 함수는 Anna가 격자판 색칠을 마칠 때마다 호출됩니다. 이 함수는
총 $Q$회 호출되며,
$i$번째 통화($1 ≤ i ≤ Q$)는 $i$번째 도전에서 5., 6.의 절차에 해당합니다.

매개변수 $N$은 5번 과정에서 Bruno에게 전달된 카드에 적힌 정수 $N_i$입니다.
매개변수 T는 $8 \time 8$ 크기의 2차원 배열으로, $i$번째 도전의 5번 과정에서 Bruno에게 주어진 격자판에 해당합니다.
$a$행($0 ≤$a$≤ 7$) $b$열($0 ≤$b$≤ 7$)은 T[a][b] = 0이면 파란색이고, T[a][b] = 1이면 빨간색입니다.
반환 값은 Bruno가 종이에 쓴 문자열입니다.
반환된 문자열이 길이 $44$ 이상의의 문자열인 경우 귀하의 프로그램은 오답[5]으로 판단됩니다.
반환 값의 각 문자는 'A' 또는 'B'여야 합니다. 이 조건이 만족되지 않으면 귀하의 프로그램은 오답[6]으로 판단됩니다.

 귀하의 프로그램은 내부 사용을 위해 다른 기능을 구현하거나 전역 변수를 사용할 수 있습니다. 제출된 파일은 그레이더와 함께 컴파일되어 단일 실행 파일이 됩니다. 모든 전역 변수와 내부 함수는 다른 파일과의 충돌을 피하기 위해 명명되지 않은 네임스페이스에서 선언되어야 합니다. 그레이딩 과정에서, Anna와 Bruno 2개의 프로세스로 실행되게 됩니다. Anna의 프로세스와 Bruno의 프로세스는 전역 변수를 공유할 수 없습니다.

프로그램은 표준 입력과 표준 출력을 사용해서는 안 됩니다. 귀하의 프로그램은 어떠한 방법으로도 다른 파일과 통신해서는 안 됩니다. 그러나 프로그램에서는 디버깅 정보를 표준 오류로 출력할 수 있습니다.
# 컴파일과 테스트 실행
프로그램을 테스트하기 위한 샘플 그레이더가 포함된 콘테스트 웹페이지에서 아카이브 파일을 다운로드할 수 있습니다. 아카이브 파일에는 프로그램의 샘플 소스 파일도 포함되어 있습니다.

샘플 그레이더는 grader.cpp 파일입니다. 프로그램을 테스트하려면 grader.cpp, Anna.cpp, Bruno.cpp, Anna.h, Bruno.h를 동일한 디렉토리에 넣고 다음 명령을 실행하여 프로그램을 컴파일하십시오. 혹은, 아카이브 파일에 포함된 compile.sh를 실행할 수 있습니다.

g++ -std=gnu++17 -O2 -o grader grader.cpp Anna.cpp Bruno.cpp
컴파일이 성공하면 실행 파일 grader 가 생성됩니다.

실제 채점자는 샘플 채점자와 다릅니다. 특히 비타로는 셀을 칠할 색상을 항상 무작위로 선택하는 것은 아닙니다. 샘플 그레이더는 표준 입력에서 입력 데이터를 읽고 결과를 표준 출력에 쓰는 단일 프로세스로 실행됩니다.

샘플 그레이더의 입력

샘플 그레이더는 표준 입력에서 다음 데이터를 읽습니다.  

샘플 그레이더의 출력

샘플 그레이더는 다음 정보를 표준 출력으로 출력합니다(명확성을 위해 인용문 참조).

프로그램이 정답으로 판단되면 값 $L^{*}$

을 "Accepted: 28"과 같이 씁니다. $L^{*}$

에 대해서는, 그레이딩 항목을 참조하십시오.
귀하의 프로그램이 가능한 오답중 어떠한 것으로든 판단되면 샘플 채점자는 해당 유형을 "Wrong Answer [1]"과 같이 작성합니다.
프로그램이 여러 유형의 오답에 해당될 경우 샘플 채점자는 그 중 하나만 보고합니다.

샘플 그레이더에서 Bitaro가 챌린지를 위해 선택한 색상은 실행마다 결과가 변경되지 않는 의사 난수에 의해 무작위로 결정됩니다. 의사난수의 시드를 변경하려면 다음과 같이 첫 번째 정수 인수를 사용하여 샘플 그레이더를 실행합니다.

./grader 2023

# 제한
$1 ≤ Q ≤ 20 000$.   
$0 ≤ X_i ≤ 7 (1 ≤ i ≤ Q)$.   
$0 ≤ Y_i ≤ 7 (1 ≤ i ≤ Q)$.   
$0 ≤ N_i ≤ 43 (1 ≤ i ≤ Q)$.   
$Q,X_i,Y_i,N_i$는 정수입니다.   
$S_i(1 ≤ i ≤ Q)$는 길이 $N_i$의 문자열로, 'A'와 'B'으로 구성되어 있습니다..   
# 점수
 만약 당신의 프로그램이 어떤 테스트케이스에 대해서라도 오답 [1]-[6]중 어떠한 것으로든 판단되거나(구현 세부사항을 참조하십시오.) 어떠한 종류의 런타임 에러(TLE(시간제한 초과), MLE(메모리제한 초과), 비정상적인 종류, 기타등등.), 당신의 점수는 다른 테스트케이스에서 도전에 성공하였는지와는 무관하게 0점입니다.

 그렇지 않다면, $L*$을 해당 문제의 모든 테스트케이스에 대해 다음의 값들중 최솟값이라 하겠습니다.
 이때, 당신의 점수는 다음의 표와 같이 나타납니다.
 - $N_i ≤ L$을 만족하는 모든 $i$에 대해서, Anna와 Bruno가 해당 도전들을 성공하게 되는 $L$의 최댓값.
 
## 예제
다음은 샘플 그레이더와, 그에 상응하는 함수들의 호출에 대한 예시 입력입니다. 매개변수 $T$ 
<table>
  <tr>
    <td rowspan="2">예시 입력1</td>
    <td colspan="4">예시 호출</td>
  </tr>
  <tr>
    <td>호출</td>
    <td>반환</td>
    <td>호출</td>
    <td>반환</td>
  </tr>
  <tr>
    <td rowspan="20">4 3<br/>0 1<br/>0 2<br/>0 3<br/></td>
    <td> Alice(...)</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
  <td></td>
  <td>InitG(4,3)</td>
  <td></td>
  </tr>
  <tr>
    <td></td>
  <td></td>
  <td></td>
  <td>(none)</td>
  </tr>
  <tr>
    <td></td>
  <td></td>
  <td>MakeG(0,0,1)</td>
  <td></td>
  </tr>
  <tr>
    <td></td>
  <td></td>
  <td></td>
  <td>(none)</td>
  </tr>
  <tr>
    <td></td>
  <td></td>
  <td>MakeG(1,0,2)</td>
  <td></td>
  </tr>
   <tr>
    <td></td>
  <td></td>
  <td></td>
  <td>(none)</td>
  </tr>
    <tr>
    <td></td>
  <td></td>
  <td>MakeG(2,0,3)</td>
  <td></td>
  </tr>
     <tr>
    <td></td>
  <td>(none)</td>
  <td></td>
  <td></td>
  </tr>
      <tr>
    <td>Bob(...)</td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
      <tr>
    <td></td>
  <td></td>
  <td>InitMap(4,3)</td>
  <td></td>
  </tr>
    <tr>
    <td></td>
  <td></td>
  <td></td>
  <td>(none)</td>
  </tr>
    <tr>
    <td></td>
  <td></td>
  <td>MakeMap(0,1)</td>
  <td></td>
  </tr>
    <tr>
    <td></td>
  <td></td>
  <td></td>
  <td>(none)</td>
  </tr>
     <tr>
    <td></td>
  <td></td>
  <td>MakeMap(0,2)</td>
  <td></td>
  </tr>
     <tr>
    <td></td>
  <td></td>
  <td></td>
  <td>(none)</td>
  </tr>
      <tr>
    <td></td>
  <td></td>
  <td>MakeMap(0,3)</td>
  <td></td>
  </tr>
     <tr>
    <td></td>
  <td></td>
  <td></td>
  <td>(none)</td>
  </tr>
      <tr>
    <td></td>
  <td>(none)</td>
  <td></td>
  <td></td>
  </tr>
</table>

 해당 예제 입력에서, 총 $Q(=2)$개의 도전이 있습니다.
 첫 도전에서, $X_1=0,Y_1=0,N_1=1,S_1="B"$입니다. Anna는 0행과 0열중 어느 것에도 속하지 않는 49개의 칸을 색칠하였습니다.
  두 번째 도전에서, $X_2=5,Y_2=7,N_2=8,S_2="AAAABBBB"$입니다. Anna는 5행에 속하지 않았으며, 7열에 속하지 않은 49개의 칸을 색칠하였습니다.
 예를 들어, 귀하의 프로그램이 Paint(0,2,1)을 첫 도전에서 호출한다면, 0행에 들어있는 칸을 색칠하려 하였기 때문에 오답[1]으로 판정될 것입니다. 여기에 샘플 그레이더에 대한 또다른 예시가 있습니다.
<table>
    30   
3 1 1 A   
1 4 1 A   
6 6 2 AA   
1 1 2 BB   
3 1 3 BAB   
7 4 3 AAB   
6 4 4 BAAB   
6 7 4 BABA   
3 3 5 BABBA   
1 5 5 ABBBA   
4 3 6 ABBBBB   
2 1 6 ABAAAA   
6 0 7 AAABABA   
6 6 7 BBABBAA   
0 4 8 AABAABAB   
2 1 8 AABBBBBA   
2 0 9 BABABBAAA   
1 5 9 BBAAABABB   
6 7 10 BAAABAAABB   
1 7 10 BBBBBBBABA   
2 6 12 AABAABABABAB   
3 4 15 BBAABAAAABABAAB   
5 6 18 BAAAABBABABBBABBAB   
7 0 22 BABBAABAAABBABBBBBBABA   
2 0 26 AAAABBABBAAAAABABABBAABAAA   
0 7 30 AAABBBAAABAABBBBAABBAAABBBABBB   
2 7 34 BABAABBAABABBABAABBABBABAABBBBABBB   
2 5 38 BBBBAABAABAABABABBBBBAAABBABAAABAAABBB   
5 2 41 AABABBAAABBABAAAABBABABBAAAAAABBABBABBABA   
1 0 43 AABBABBBBABABBBABBBBAAAAAABABAAABBBAABBAAAB   
</table>

+ ## $L^*=$ ( $37점$)
 다양한 풀이가 있을 수 있습니다. 추후 풀이로 확장하기 가장 쉬운 풀이는, 그래프의 정점들을 특정한 방식으로 구분하는 풀이입니다. 정점들은 많아야 40개이고 하나의 정점과 연결된 기존의 간선들도 많아야 39개이기 때문에, 예를 들어 1000개의 새로운 정점을 추가한 뒤, 1번 정점을 50개의 새로운 정점과 연결하고, 2번 정점을 100개의 새로운 정점과 연결하고, ..., 10번 정점을 500개의 새로운 정점과 연결하는 방식을 쓰고, 각 새로운 정점들은 서로 연결했다고 해봅시다. 그렇다면 정점의 번호가 사라져도 새로 추가된 정점을 구분할 수 있고, 새로 추가된 간선에 의한 차수를 계산하면 각 정점들이 기존에는 몇번 정점이었는지 알아낼 수 있습니다.
+ ## Subtask 3. ( $100점$)
 위의 풀이에서는 기존의 정점들을 분간해내기 위해 i번 정점에 $k *i$개의 정점을 새로 연결해주었지만, 사실 굳이 선형적인 방식으로 정점을 연결해줄 필요는 없습니다. 왜냐하면 새로운 정점들과 간선들을 적당히 추가하면, 새로운 정점들끼리 구분되도록 할 수 있기 때문입니다. 그렇다면, 어떤 방법을 써야 새로운 정점들을 알아내면서, 그들에게 매겼던 번호도 알아낼 수 있을까요?
 한 가지 생각해볼 수 있는 것은, 이를테면 다음과 같은 방법입니다:
 1. 정확히 하나의 정점을 제외하고 모든 다른 정점들과 연결된 정점(A)과, 연결되지 않은 정점(B) 두 개를 집어넣습니다(이후에 추가하는 정점들과도 연결되어있습니다)
 2. B와 기존에 존재했던 어떤 정점 사이에도 연결은 존재하지 않습니다.
 3. 새로운 10개의 정점들을 추가하는데, 이들끼리는 특정한 트리의 구조로 연결되어있습니다. 또한, B와 이 10개의 정점들을 전부 연결해줍니다.
 4. 새로 추가한 10개의 정점들중 i번째 정점에 대해서, 기존 정점의 i번째 비트가 켜져있다면 해당 정점과 연결합니다.

 이제 이러한 세팅하에서 어떤 방식으로 문제가 풀릴지 생각해봅시다.   
 일단, 첫번째로 지정한 정점인 A는 무조건 찾아낼 수 있습니다. A의 차수는 (전체 정점의 개수-2)입니다. 3번째 스텝에서 추가한 정점들은 트리와 같이 연결되어있기 때문에, 적어도 3개의 정점들에 대해서는 간선이 없습니다. 따라서 용의선상에서 제외됩니다. 2번 스텝에서 추가한 정점의 경우에는, (기존 정점의 개수+1(A)+1(자신))만큼의 정점들과 연결되지 않는데, 따라서 차수가 (전체 정점의 개수-3) 이하입니다. 따라서 B도 아닙니다. 기존에 존재했던 정점들의 경우에는 i번 정점의 경우 (전체 정점의 개수-(10-(i의 켜진 비트수))-2) 이하의 차수를 가지게 되는데, 10개의 비트가 켜진 i는 존재하지 않기 때문에 이들도 조건을 만족할 수 없습니다. 따라서 오로지 A만이 최대 차수를 가집니다.   
 A를 구분했기 때문에, 이제 B도 알아낼 수 있습니다. B를 알아내었다는 것은, B와 연결된 10개의 정점들을 알아낼 수 있음을 의미합니다. 만약 10개의 정점들을 연결한 트리의 상태가 굉장히 비대칭적이라면, 각 정점들이 몇번이었는지 또한 알아낼 수 있을 것입니다(알아내었다고 가정해봅시다.). 그렇다면, 총 10개의 정점이 있으므로 기존의 정점들을 1023번째까지를 표현할 수 있고, 이는 전체 문제의 제한인 1000을 넘으므로 문제가 해결됩니다!   
 비대칭 트리를 구성하는 방법은 몇가지가 있을 수 있는데, 한 가지 방법은 다음과 같습니다:   
(1,2)   
(2,3)   
(3,4)   
(4,5)   
(5,6)   
(6,7)   
(1,8)   
(1,9)   
(9,10)  
실제로 해당 간선들을 통해 트리를 그려보면, 1만이 3의 차수를 가지고 그로부터 파생되는 각 가지들의 길이가 서로 다름을 알 수 있습니다. 따라서 각 가지를 특정할 수 있고, 그 가지에 들어있는 정점들도 구분할 수 있습니다.
