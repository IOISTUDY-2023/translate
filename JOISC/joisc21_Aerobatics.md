# Aerobatics (JOISC 2021)
## 문제 링크
BOJ([테스트케이스 1](https://www.acmicpc.net/problem/21779), [2](https://www.acmicpc.net/problem/21780), [3](https://www.acmicpc.net/problem/21781), [4](https://www.acmicpc.net/problem/21782), [5](https://www.acmicpc.net/problem/21783), [6](https://www.acmicpc.net/problem/21784)), [oj.uz](https://oj.uz/problem/view/JOI21_aerobatics), [LibreOJ](https://loj.ac/p/3487), [QOJ](https://qoj.ac/problem/3092)

## 문제
기범이는 곡예비행 대회에 출전해서 비행기를 조종하려고 한다. 비행기는 일정한 고도를 날며 N개의 지점을 통과해야 한다. 각 지점은 $1$부터 $N$까지의 번호를 가지고 있다. 이때 $i$번 지점($1 \leq i \leq N$)은 좌표 $(X_i,Y_i)$에 위치해 있다.

기범이는 비행기를 타고 모든 지점을 $1$번씩 통과해야 한다. 더 엄밀히 설명하면 다음과 같다.
1. $N$개의 지점 중 처음 출발할 지점 하나를 선택한다. 이 지점은 이미 방문한 것으로 간주한다.
2. 다음을 $N-1$회 반복한다. 아직까지 방문하지 않은 지점 중 지점 $1$개를 선택하여, 현재 비행기가 위치한 지점부터 선택한 지점까지 직선으로 날아간다.
3. 2.를 모두 수행하여 $N$번째 지점에 도달하면 비행이 끝난다.

2.에서, 비행기는 지점에서 지점으로 날 때마다 항상 일직선으로 비행해야 한다. 이렇게 하면, 기범이가 비행하는 경로는 선분 $N-1$개와 각 $N-2$개로 이루어진 도형이 된다.

이때, 한 점에서 만나는 두 선분 경로 사이의 각이 작으면 비행기의 방향 변화가 크기 때문에 비행에 실패할 확률이 더 크다. 때문에, 기범이는 $N-2$개 각의 크기 중 최솟값이 최대가 되도록 경로를 설정하려고 한다.

각 지점의 좌표가 주어질 때, 각의 크기의 최솟값이 최대가 되게 하는 지점 방문 순서를 계산하는 프로그램을 작성하여라.

## 입력
첫째 줄에 지점의 수 $N$과 변수 $Z_0$가 주어진다. $Z_0$은 그레이더에서 사용하는 변수이다.
둘째 줄부터 $N$개의 줄에 각 지점의 좌표 $X_i$, $Y_i$가 주어진다.

## 출력
$i$번째 줄에 $i$번째로 방문할 지점의 번호를 출력한다. $(1 \leq i \leq n)$

## 제한
* $3 \leq N \leq 1000$
* $\sqrt{Xi^2+Yi^2} \leq 10000000$ $(1 \leq i \leq N)$
* $(X_i, Y_i) \neq (X_j, Y_j)$ $(1 \leq i < j \leq N)$
* $1 \leq Z_0 \leq 179$
점수 탭에서 6개의 입력 데이터를 모두 다운받을 수 있다.

## 라이브러리
이 문제에서 여러분은 세 점이 이루는 각의 크기를 계산하는 함수를 사용할 수 있다. 라이브러리는 [첨부파일](https://upload.acmicpc.net/c797d43d-2a9d-4dfe-83d6-73f56495a8a0/)의 aerobatics.h 파일에 저장되어 있다. 함수는 다음과 같이 사용할 수 있다.
```c++
double GetAngle(int xa, int ya, int xb, int yb, int xc, int yc)
```
본 함수는 각 $BAC$를 도(degree) 단위로 계산한다. 반환값은 double 형식의 실수이며, 오차는 매우 작다.\
$xa$, $ya$는 점 $A$의 좌표, $xb$, $yb$는 점 $B$의 좌표, $xc$, $yc$는 점 $C$의 좌표이다.\
점 $A$와 $B$가 같거나 점 $A$와 $C$가 같을 경우 함수의 정상 작동을 보장하지 않는다.\
제출하는 코드에서 GetAngle 코드를 사용할 수 있다. 이 함수는 그레이더에서 사용하는 함수와 동일하다. 다만, 필요한 경우 함수를 수정하여 사용해도 좋다.
> BOJ에서는 총 6개의 입력 데이터별로 출력 결과를 따로 받고 있다. 따라서 답안을 text로 제출하여도 된다.

## 점수
각 입력에 대해, 점수는 다음과 같이 계산된다.
출력이 틀릴 경우, 즉 출력 형식이 잘못되었거나 출력한 $N$개의 수가 $1$부터 $N$까지의 수를 하나씩 포함하고 있지 않은 경우, 0점을 받게 된다.
그렇지 않다면, 점수를 다음과 같이 계산한다.
$N-2$개의 각 중 최솟값을 $Z$라고 하자. $Z \geq Z_0$인 경우 점수 $S$를 받게 되며, $Z < Z_0$인 경우 $S*f(Z/180)/f(Z_0/180)$만큼의 점수를 받게 된다. 이때 $f(x)$는 정의역이 $[0,1]$인 함수로 $f(x)=4x^4+x$이다.
받는 점수의 총합은 6개의 입력 데이터에 대한 점수의 합을 반올림한 값이다. 6개의 입력 데이터는 다음과 같다.
* 1번 : [input_01.txt](http://upload.acmicpc.net/619e6ddd-dbf6-4cea-b0f8-9e8d69c1542c/), $N = 15$, $Z_0 = 100$, 10점
* 2번 : [input_02.txt](http://upload.acmicpc.net/858c84c9-be53-4157-9fd7-7b50f65f612a/), $N = 200$, $Z_0 = 143$, 15점
* 3번 : [input_03.txt](http://upload.acmicpc.net/4ac96dfd-9adc-4a13-8525-d873298a90ba/), $N = 200$, $Z_0 = 134$, 15점
* 4번 : [input_04.txt](http://upload.acmicpc.net/5db94ea0-5d12-47ae-8155-845c1d1d5bb0/), $N = 1000$, $Z_0 = 156$, 20점
* 5번 : [input_05.txt](http://upload.acmicpc.net/3af3ef7e-1322-4e01-b7c7-afbfd866670e/), $N = 1000$, $Z_0 = 150$, 20점
* 6번 : [input_06.txt](http://upload.acmicpc.net/c3388e76-ac0f-4f3e-bced-86b61c5b0bc0/), $N = 1000$, $Z_0 = 153$, 20점

## 예제
### 입력
```
7 90
3 1 
2 5 
0 2 
-1 6
-3 1
-1 -4
4 -2
```

### 출력
```
5
3
1
7
6
4
2
```

### 설명
비행기가 5, 3, 1, 7, 6, 4, 2 순으로 비행할 경우, 최소각은 6번 지점에 있으며 이 각의 크기는 68.19이다. $Z_0 = 90$ 이므로, 예제와 같이 출력하면 만점의 61.5%에 해당하는 점수를 받게 된다.

## 해설
본 문제는 Output-only 문제로, 주어진 6개의 테스트케이스에 대해서 조건에 맞게 적절한 해를 찾아 얻을 수 있는 출력만을 제출하면 되는 문제입니다.\
또한, 비행 경로의 최소각의 크기에 따라서 점수를 부여받기 때문에 **완벽한 해를 찾을 필요 없이 대략적으로 답을 출력해도 됩니다.**\
이 풀이에서는 100점 만점 중 대략 95점 정도를 도달할 수 있는 풀이를 설명합니다. 물론 동일 풀이를 수 시간동안 돌리면 100점 도달도 이론적으로는 가능합니다.
### 아이디어 1: 비트마스킹 DP
**여기서부터는, 두 선분 경로 사이의 각을 '선회각'이라고 합시다.** (쉬운 풀이 작성을 위해 임의로 정한 용어입니다.)\
테스트케이스 1번의 경우 지점의 수가 15개이기 때문에, 대충 **Bitmask DP**를 돌아보면 최적해를 구할 수 있습니다. 각 상태는 현재 위치한 지점, 직전에 위치했던 지점, 이전에 방문했던 지점들의 비트마스크로 정의하고, 각 원소의 값은 그 경로의 최소 선회각을 저장해두면 됩니다. 시간복잡도는 $O(2^n * N^3)$ 입니다. 
### 아이디어 2: 무작위화하여 방문하기
적당한 경로를 제시하면 부분점수를 받을 수 있으므로, 그냥 **주어진 지점들을 무작위하게 정렬**해서 출력하는 것을 시도할 수 있습니다. 
출제진이 무작위한 방법으로 얻은 점수는 7점입니다. 더 높은 점수를 받는 것도 물론 가능하겠지만 아마 무작위한 방법만으로는 많은 시도가 필요할 것입니다.
### 아이디어 3: 그리디 알고리즘
처음 두 점을 적절하게 고른 뒤, 갈 수 있는 **남은 지점 중에 가장 선회각이 180도에 가깝도록 다음 지점을 선택**하는 방법을 시도할 수 있습니다.\
처음 두 점을 잡는 방법으로는 여러 가지가 있을 수 있습니다. 예를 들어서, 첫 번째 지점은 x좌표가 가장 큰 점으로, 두 번째 지점은 첫 번째 지점과 이루는 경로가 y축과 이루는 각이 가장 작은 점으로 설정할 경우 6개 테스트케이스에서 총 14점을 획득할 수 있고, 처음 두 개의 점 조합을 모두 계산한다면 총 28점을 획득할 수 있습니다. \
*이때 시간복잡도는 $O(N^4)$이므로, $N = 2000$인 테스트케이스의 경우 각각 20분 정도를 소요해야 해를 얻을 수 있습니다. 컴퓨터를 한 시간 넘게 혹사시킨 것 치고는 그리 만족스럽지 못한 점수인 것 같습니다.*
### 아이디어 4: Hill Climbing Search
Hill Climbing 탐색 방법은, 해 하나가 있을 때 이 해를 개선할 수 있는 부분을 찾아서 그 부분을 개선해주는 휴리스틱 풀이법입니다. 더 이상 개선할 수 없을 때까지 해의 개선을 반복해주면 꽤나 좋은 해를 얻을 수 있습니다.\
예를 들어 다음과 같은 접근을 사용해봅시다: 현재 경로에서 **무작위로 임의의 두 점을 선택**해서, 만약 두 점의 **방문 순서를 바꾸었을 때 경로의 최소 회전각이 직전 상태와 같거나 더 작아진다면** 두 점의 순서를 바꿉니다.\
영원히 탐색을 계속할 수는 없으므로, 적절하게 $5N^2$회 연속으로 최소 회전각이 더 작은 해를 찾지 못했다면 탐색을 종료하는 것으로 합시다.\
초기 경로는 무엇을 골라도 상관없습니다. 풀이법 2의 그리디 알고리즘으로 얻은 해 하나를 초기해로 이용해도 되고, 무작위하게 경로를 하나 지정해서 이를 초기해로 이용해도 됩니다. 풀이에서는 1 > 2 > 3 > ... > N 의 경로를 초기해로 사용했습니다.\
이를 통해 총 45점을 받을 수 있었습니다.
### 아이디어 5: 2-opt HC
위에서 설명한 풀이로도 충분히 좋은 해를 찾을 수 있었습니다. 그러나 이로 전체 최적해를 찾지 못하는 이유는 두 지점만 바꾸는 방법이 너무 지역적인 최적해에 갇히기 쉽다는 것에 있습니다. 그렇다면 더 많은 해를 탐색할 수 있도록, '두 정점'보다 많은 변화를 주면 됩니다.\
이번에는 현재 경로에서 임의로 두 개의 경로를 선택해 봅시다. 그리고 두 점의 순서를 바꾸는 것 대신 두 경로의 출발지를 서로 바꾸어 줍시다.\
두 개의 정점을 바꾸어주는 것은 한 번에 최대 6개의 회전각을 바꾸게 되는 반면, 경로를 바꾸는 것은 최대 4개의 회전각만을 바꾸기 때문에 해를 '움직이기' 더 쉽습니다.\
두 경로 바꾸기를 사용해 경로를 최적화하는 것을 2-opt라고 부르기도 합니다. TSP 문제에서 많이 사용하는 기법입니다. \
이를 통해 총 69점을 받을 수 있었습니다.
### 아이디어 6: 평가함수의 개선
지금까지 최적해는 최소 선회각이 더 큰 것을 기준으로 하여 선정했습니다. 어차피 가장 작은 각이 커져도 두 번째로 작은 각의 크기가 비슷했으면 개선이 일어나지 않으니까, 아예 가장 작은 5개 정도의 각의 합을 최적해를 선정하는 평가함수의 기준으로 두면 어떨까요?\
그리디 알고리즘(풀이법 2)로 얻은 해를 최초해로 하고, 평가함수를 이처럼 두면 점수를 80점 정도로 끌어올릴 수 있습니다.
### 아이디어 7: 경로 교환 연산의 상수 시간 구현
두 경로를 바꾸는 연산은 두 가지가 가능한데, 이중 어떤 것이 맞는 방향인지를 알 수 없습니다. 때문에 둘 중 맞는 것을 찾는데 이미 $O(N)$을 소요하고 있습니다. 그렇다면 사이클이 만들어지는 것을 허용해 봅시다!\
사이클이 만들어지는 것을 허용한다고 해서 사이클이 우후죽순 생겨나지는 않습니다. 그 이유는, 완전히 랜덤한 경우에서 사이클은 $log_eN$개의 기댓값으로 만들어지기 때문입니다. 최적해 탐색이 끝난 이후에는 경로 바꾸기를 통해 사이클을 없앨 수 있습니다. 이때 사이클을 없애면서 최소 선회각이 변하는 확률이 매우 작기 때문에, 이렇게 하면 두 경로를 바꾸는 연산을 높은 확률으로 상수 시간으로 구현할 수 있게 됩니다.
### 아이디어 8: 그리디 알고리즘의 해를 활용한 평가함수의 개선
그리디 알고리즘으로 얻게 되는 초기해는 생각보다 좋은 해입니다. 최소 선회각과는 별개로, 150도 이상의 나름 각도가 큰 선회각들도 많이 찾을 수 있습니다. 그러나 현재의 평가함수는 가장 작은 5개의 선회각을 제외하고는 평가에 반영하지 않기 때문에, 좋은 해를 버리는 악효과가 발생합니다. 이런 해들을 잘 활용해서 평가함수를 좀 더 효율적으로 짤 수는 없을까요?\
한 가지 방법은, 어떤 기준각을 잡아 놓고 그 크기가 기준각보다 더 큰 선회각의 개수를 평가함수로 지정하는 것입니다. 그러면 큰 각들은 최대한 유지하면서 작은 각의 크기를 키워나갈 수 있을 것입니다. 그러나, 이렇게 하면 가장 작은 각을 키우기는 더 어려워질 것입니다.\
가장 작은 각과 큰 각들을 모두 평가함수에 반영할 수 있도록 해봅시다. 기준각보다 크기가 큰 선회각의 경우 '만점 점수'에 해당하는 점수를 주고($X$라 합시다), 그렇지 않은 경우 선회각에서 기준각을 뺀 값(당연히 음수입니다)를 줍니다. 이들을 모두 합한 것을 평가함수로 두어 봅시다.\
이렇게 하면, (물론 더 복잡해진 것 같지만,) 한 번의 경로 교환 당 바뀌는 각의 크기는 최대 4이므로 평가함수를 상수 시간으로 구현할 수 있습니다.\
이를 이용하여, 테스트케이스별로 만점 점수 $X$에 입력되는 변수 $Z_0$보다 2에서 3 정도 낮은 값을 대입하면 $O(10^8)$ ~ $O(10^9)$ 사이에서 90점 이상의 점수를 얻을 수 있습니다.
### 아이디어 9: 해의 다양성에 대해서
조금 더 높은 점수를 목표로 해 봅시다. 기존에는 평가함수의 값이 높아지거나 같을 경우 경로해를 변경했습니다. 그러나 조금 더 다양한 해를 탐색할 수 있도록, 평가함숫값이 조금은 내려가는 경우에도 이를 새로운 해로 적용합시다. 이 역시도, 적절한 변수 $Y$를 잡아 평가함숫값이 $Y$배 이상으로 변하는 경우 해로 적용할 수 있습니다. 이렇게 하면, 동일한 연산 횟수에 대해 2점 정도 더 높은 점수를 받을 수 있습니다.
### 아이디어 10: 더 높은 점수를 향해
사실 이 문제에서 만점을 받기는 굉장히 어렵습니다. 풀이 작성자인 저의 경우, DP를 이용해 해결한 1번 테스트케이스를 제외하면 2번에서 171402096849($=O(1e11)$)회, 3번에서 1497594757($=O(1e9)$)회, 4번에서 36891708048($=O(3e10)$)회, 5번에서 12563420022($=O(1e10)$)회의 연산을 통해 만점 해를 계산해내었습니다. *물론 각 연산은 경로 수정과 평가함수 구동 모두를 동반하기 때문에, 대략 400만 회 연산 당 1초로 계산하는 것이 더 적절합니다.*
#### 아이디어 11: 테스트케이스 6번에 대해서
테스트케이스 6번은 각 지점들이 동심원 약 20개 중 하나의 위에 균등하게 분포하여 있는 테스트케이스입니다. 이 경우 20개의 동심원이 각각 하나의 사이클으로 형성되면 사이클을 없애는 과정에서 최소 선회각이 더 작아질 확률이 많이 높아집니다. 따라서, 아예 초기해를 그리디 알고리즘의 해가 아닌 무작위 수열으로 두는 것을 시도할 수 있겠습니다.\
이를 고려하면서 동일한 코드를 구현하면, (2~5번 테스트케이스보다는) 비교적 매우 짧은 시간 내에 만점을 받는 해를 찾을 수 있습니다.

이제 할 수 있는 방법은, $X$와 $Y$의 변숫값을 잘 조절해가면서 인내심을 가지고 코드가 해를 찾을 때까지 기다리는 것입니다. 원하신다면 [이 링크](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day1/aerobatics-sample.cpp)에서 문제의 정해 풀이와 **출제자의 최적 변숫값**을 확인할 수 있습니다. 그러나 여기까지 따라오셨다면 변숫값을 조절하여 적당하게 해를 뽑아내는 것은 충분히 할 수 있다고 봅니다.\
2-opt의 최적화를 기반으로 한 TSP 풀이만으로 이 문제를 풀 수 있지는 않습니다. 담금질 기법이나 DLAS 등의 더 효율적인 휴리스틱 알고리즘을 통해 더 빠르게, 혹은 더 높은 점수를 받는 해를 찾을 수 있을지도 모릅니다. 이것은 여러분께 맡기겠습니다.\
아무튼, 이 단계까지 오셨다면 기범이의 완벽한 비행을 위해서 꼭 100점 완성에 성공하셨으면 합니다. 

<!--
{"title":"Aerobatics","author":"윤지호","content":[{"title":"문제","type":"textarea","content":"BOJ([테스트케이스 1](https://www.acmicpc.net/problem/21779), [2](https://www.acmicpc.net/problem/21780), [3](https://www.acmicpc.net/problem/21781), [4](https://www.acmicpc.net/problem/21782), [5](https://www.acmicpc.net/problem/21783), [6](https://www.acmicpc.net/problem/21784)), [oj.uz](https://oj.uz/problem/view/JOI21_aerobatics), [LibreOJ](https://loj.ac/p/3487), [QOJ](https://qoj.ac/problem/3092)\r\n\r\n기범이는 곡예비행 대회에 출전해서 비행기를 조종하려고 한다. 비행기는 일정한 고도를 날며 N개의 지점을 통과해야 한다. 각 지점은 $1$부터 $N$까지의 번호를 가지고 있다. 이때 $i$번 지점($1 \\leq i \\leq N$)은 좌표 $(X_i,Y_i)$에 위치해 있다.\r\n\r\n기범이는 비행기를 타고 모든 지점을 $1$번씩 통과해야 한다. 더 엄밀히 설명하면 다음과 같다.\r\n1. $N$개의 지점 중 처음 출발할 지점 하나를 선택한다. 이 지점은 이미 방문한 것으로 간주한다.\r\n2. 다음을 $N-1$회 반복한다. 아직까지 방문하지 않은 지점 중 지점 $1$개를 선택하여, 현재 비행기가 위치한 지점부터 선택한 지점까지 직선으로 날아간다.\r\n3. 2.를 모두 수행하여 $N$번째 지점에 도달하면 비행이 끝난다.\r\n\r\n2.에서, 비행기는 지점에서 지점으로 날 때마다 항상 일직선으로 비행해야 한다. 이렇게 하면, 기범이가 비행하는 경로는 선분 $N-1$개와 각 $N-2$개로 이루어진 도형이 된다.\r\n\r\n이때, 한 점에서 만나는 두 선분 경로 사이의 각이 작으면 비행기의 방향 변화가 크기 때문에 비행에 실패할 확률이 더 크다. 때문에, 기범이는 $N-2$개 각의 크기 중 최솟값이 최대가 되도록 경로를 설정하려고 한다.\r\n\r\n각 지점의 좌표가 주어질 때, 각의 크기의 최솟값이 최대가 되게 하는 지점 방문 순서를 계산하는 프로그램을 작성하여라."},{"title":"입력","type":"textarea","content":"첫째 줄에 지점의 수 $N$과 변수 $Z_0$가 주어진다. $Z_0$은 그레이더에서 사용하는 변수이다.\r\n둘째 줄부터 $N$개의 줄에 각 지점의 좌표 $X_i$, $Y_i$가 주어진다."},{"title":"출력","type":"textarea","content":"$i$번째 줄에 $i$번째로 방문할 지점의 번호를 출력한다. $(1 \\leq i \\leq n)$"},{"title":"제한","type":"textarea","content":"* $3 \\leq N \\leq 1000$\r\n* $\\sqrt{Xi^2+Yi^2} \\leq 10000000$ $(1 \\leq i \\leq N)$\r\n* $(X_i, Y_i) \\neq (X_j, Y_j)$ $(1 \\leq i < j \\leq N)$\r\n* $1 \\leq Z_0 \\leq 179$\r\n점수 탭에서 6개의 입력 데이터를 모두 다운받을 수 있다."},{"title":"라이브러리","type":"textarea","content":"이 문제에서 여러분은 세 점이 이루는 각의 크기를 계산하는 함수를 사용할 수 있다. 라이브러리는 [첨부파일](https://upload.acmicpc.net/c797d43d-2a9d-4dfe-83d6-73f56495a8a0/)의 aerobatics.h 파일에 저장되어 있다. 함수는 다음과 같이 사용할 수 있다.\r\n```c++\r\ndouble GetAngle(int xa, int ya, int xb, int yb, int xc, int yc)\r\n```\r\n본 함수는 각 $BAC$를 도(degree) 단위로 계산한다. 반환값은 double 형식의 실수이며, 오차는 매우 작다.\\\r\n$xa$, $ya$는 점 $A$의 좌표, $xb$, $yb$는 점 $B$의 좌표, $xc$, $yc$는 점 $C$의 좌표이다.\\\r\n점 $A$와 $B$가 같거나 점 $A$와 $C$가 같을 경우 함수의 정상 작동을 보장하지 않는다.\\\r\n제출하는 코드에서 GetAngle 코드를 사용할 수 있다. 이 함수는 그레이더에서 사용하는 함수와 동일하다. 다만, 필요한 경우 함수를 수정하여 사용해도 좋다.\r\n> BOJ에서는 총 6개의 입력 데이터별로 출력 결과를 따로 받고 있다. 따라서 답안을 text로 제출하여도 된다."},{"title":"점수","type":"textarea","content":"각 입력에 대해, 점수는 다음과 같이 계산된다.\r\n출력이 틀릴 경우, 즉 출력 형식이 잘못되었거나 출력한 $N$개의 수가 $1$부터 $N$까지의 수를 하나씩 포함하고 있지 않은 경우, 0점을 받게 된다.\r\n그렇지 않다면, 점수를 다음과 같이 계산한다.\r\n$N-2$개의 각 중 최솟값을 $Z$라고 하자. $Z \\geq Z_0$인 경우 점수 $S$를 받게 되며, $Z < Z_0$인 경우 $S*f(Z/180)/f(Z_0/180)$만큼의 점수를 받게 된다. 이때 $f(x)$는 정의역이 $[0,1]$인 함수로 $f(x)=4x^4+x$이다.\r\n받는 점수의 총합은 6개의 입력 데이터에 대한 점수의 합을 반올림한 값이다. 6개의 입력 데이터는 다음과 같다.\r\n* 1번 : [input_01.txt](http://upload.acmicpc.net/619e6ddd-dbf6-4cea-b0f8-9e8d69c1542c/), $N = 15$, $Z_0 = 100$, 10점\r\n* 2번 : [input_02.txt](http://upload.acmicpc.net/858c84c9-be53-4157-9fd7-7b50f65f612a/), $N = 200$, $Z_0 = 143$, 15점\r\n* 3번 : [input_03.txt](http://upload.acmicpc.net/4ac96dfd-9adc-4a13-8525-d873298a90ba/), $N = 200$, $Z_0 = 134$, 15점\r\n* 4번 : [input_04.txt](http://upload.acmicpc.net/5db94ea0-5d12-47ae-8155-845c1d1d5bb0/), $N = 1000$, $Z_0 = 156$, 20점\r\n* 5번 : [input_05.txt](http://upload.acmicpc.net/3af3ef7e-1322-4e01-b7c7-afbfd866670e/), $N = 1000$, $Z_0 = 150$, 20점\r\n* 6번 : [input_06.txt](http://upload.acmicpc.net/c3388e76-ac0f-4f3e-bced-86b61c5b0bc0/), $N = 1000$, $Z_0 = 153$, 20점"},{"input":{"title":"예제 입력 1","content":"7 90\r\n3 1 \r\n2 5 \r\n0 2 \r\n-1 6\r\n-3 1\r\n-1 -4\r\n4 -2"},"output":{"title":"예제 출력 1","content":"5\r\n3\r\n1\r\n7\r\n6\r\n4\r\n2"},"type":"example","content":"비행기가 5, 3, 1, 7, 6, 4, 2 순으로 비행할 경우, 최소각은 6번 지점에 있으며 이 각의 크기는 68.19이다. $Z_0 = 90$ 이므로, 예제와 같이 출력하면 만점의 61.5%에 해당하는 점수를 받게 된다."},{"title":"해설","type":"textarea","content":"본 문제는 Output-only 문제로, 주어진 6개의 테스트케이스에 대해서 조건에 맞게 적절한 해를 찾아 얻을 수 있는 출력만을 제출하면 되는 문제입니다.\\\r\n또한, 비행 경로의 최소각의 크기에 따라서 점수를 부여받기 때문에 **완벽한 해를 찾을 필요 없이 대략적으로 답을 출력해도** 됩니다.\\\r\n이 풀이에서는 100점 만점 중 대략 95점 정도를 도달할 수 있는 풀이를 설명합니다. 물론 동일 풀이를 수 시간동안 돌리면 100점 도달도 이론적으로는 가능합니다.\r\n### 아이디어 1: 비트마스킹 DP\r\n**여기서부터는, 두 선분 경로 사이의 각을 '선회각'이라고 합시다.** (쉬운 풀이 작성을 위해 임의로 정한 용어입니다.)\\\r\n테스트케이스 1번의 경우 지점의 수가 15개이기 때문에, 대충 **Bitmask DP**를 돌아보면 최적해를 구할 수 있습니다. 각 상태는 현재 위치한 지점, 직전에 위치했던 지점, 이전에 방문했던 지점들의 비트마스크로 정의하고, 각 원소의 값은 그 경로의 최소 선회각을 저장해두면 됩니다. 시간복잡도는 $O(2^n * N^3)$ 입니다. \r\n### 아이디어 2: 무작위화하여 방문하기\r\n적당한 경로를 제시하면 부분점수를 받을 수 있으므로, 그냥 **주어진 지점들을 무작위하게 정렬**해서 출력하는 것을 시도할 수 있습니다. \r\n출제진이 무작위한 방법으로 얻은 점수는 7점입니다. 더 높은 점수를 받는 것도 물론 가능하겠지만 아마 무작위한 방법만으로는 많은 시도가 필요할 것입니다.\r\n### 아이디어 3: 그리디 알고리즘\r\n처음 두 점을 적절하게 고른 뒤, 갈 수 있는 **남은 지점 중에 가장 선회각이 180도에 가깝도록 다음 지점을 선택**하는 방법을 시도할 수 있습니다.\\\r\n처음 두 점을 잡는 방법으로는 여러 가지가 있을 수 있습니다. 예를 들어서, 첫 번째 지점은 x좌표가 가장 큰 점으로, 두 번째 지점은 첫 번째 지점과 이루는 경로가 y축과 이루는 각이 가장 작은 점으로 설정할 경우 6개 테스트케이스에서 총 14점을 획득할 수 있고, 처음 두 개의 점 조합을 모두 계산한다면 총 28점을 획득할 수 있습니다. \\\r\n*이때 시간복잡도는 $O(N^4)$이므로, $N = 2000$인 테스트케이스의 경우 각각 20분 정도를 소요해야 해를 얻을 수 있습니다. 컴퓨터를 한 시간 넘게 혹사시킨 것 치고는 그리 만족스럽지 못한 점수인 것 같습니다.*\r\n### 아이디어 4: Hill Climbing Search\r\nHill Climbing 탐색 방법은, 해 하나가 있을 때 이 해를 개선할 수 있는 부분을 찾아서 그 부분을 개선해주는 휴리스틱 풀이법입니다. 더 이상 개선할 수 없을 때까지 해의 개선을 반복해주면 꽤나 좋은 해를 얻을 수 있습니다.\\\r\n예를 들어 다음과 같은 접근을 사용해봅시다: 현재 경로에서 **무작위로 임의의 두 점을 선택**해서, 만약 두 점의 **방문 순서를 바꾸었을 때 경로의 최소 회전각이 직전 상태와 같거나 더 작아진다면** 두 점의 순서를 바꿉니다.\\\r\n영원히 탐색을 계속할 수는 없으므로, 적절하게 $5N^2$회 연속으로 최소 회전각이 더 작은 해를 찾지 못했다면 탐색을 종료하는 것으로 합시다.\\\r\n초기 경로는 무엇을 골라도 상관없습니다. 풀이법 2의 그리디 알고리즘으로 얻은 해 하나를 초기해로 이용해도 되고, 무작위하게 경로를 하나 지정해서 이를 초기해로 이용해도 됩니다. 풀이에서는 1 > 2 > 3 > ... > N 의 경로를 초기해로 사용했습니다.\\\r\n이를 통해 총 45점을 받을 수 있었습니다.\r\n### 아이디어 5: 2-opt HC\r\n위에서 설명한 풀이로도 충분히 좋은 해를 찾을 수 있었습니다. 그러나 이로 전체 최적해를 찾지 못하는 이유는 두 지점만 바꾸는 방법이 너무 지역적인 최적해에 갇히기 쉽다는 것에 있습니다. 그렇다면 더 많은 해를 탐색할 수 있도록, '두 정점'보다 많은 변화를 주면 됩니다.\\\r\n이번에는 현재 경로에서 임의로 두 개의 경로를 선택해 봅시다. 그리고 두 점의 순서를 바꾸는 것 대신 두 경로의 출발지를 서로 바꾸어 줍시다.\\\r\n두 개의 정점을 바꾸어주는 것은 한 번에 최대 6개의 회전각을 바꾸게 되는 반면, 경로를 바꾸는 것은 최대 4개의 회전각만을 바꾸기 때문에 해를 '움직이기' 더 쉽습니다.\\\r\n두 경로 바꾸기를 사용해 경로를 최적화하는 것을 2-opt라고 부르기도 합니다. TSP 문제에서 많이 사용하는 기법입니다. \\\r\n이를 통해 총 69점을 받을 수 있었습니다.\r\n### 아이디어 6: 평가함수의 개선\r\n지금까지 최적해는 최소 선회각이 더 큰 것을 기준으로 하여 선정했습니다. 어차피 가장 작은 각이 커져도 두 번째로 작은 각의 크기가 비슷했으면 개선이 일어나지 않으니까, 아예 가장 작은 5개 정도의 각의 합을 최적해를 선정하는 평가함수의 기준으로 두면 어떨까요?\\\r\n그리디 알고리즘(풀이법 2)로 얻은 해를 최초해로 하고, 평가함수를 이처럼 두면 점수를 80점 정도로 끌어올릴 수 있습니다.\r\n### 아이디어 7: 경로 교환 연산의 상수 시간 구현\r\n두 경로를 바꾸는 연산은 두 가지가 가능한데, 이중 어떤 것이 맞는 방향인지를 알 수 없습니다. 때문에 둘 중 맞는 것을 찾는데 이미 $O(N)$을 소요하고 있습니다. 그렇다면 사이클이 만들어지는 것을 허용해 봅시다!\\\r\n사이클이 만들어지는 것을 허용한다고 해서 사이클이 우후죽순 생겨나지는 않습니다. 그 이유는, 완전히 랜덤한 경우에서 사이클은 $log_eN$개의 기댓값으로 만들어지기 때문입니다. 최적해 탐색이 끝난 이후에는 경로 바꾸기를 통해 사이클을 없앨 수 있습니다. 이때 사이클을 없애면서 최소 선회각이 변하는 확률이 매우 작기 때문에, 이렇게 하면 두 경로를 바꾸는 연산을 높은 확률으로 상수 시간으로 구현할 수 있게 됩니다.\r\n### 아이디어 8: 그리디 알고리즘의 해를 활용한 평가함수의 개선\r\n그리디 알고리즘으로 얻게 되는 초기해는 생각보다 좋은 해입니다. 최소 선회각과는 별개로, 150도 이상의 나름 각도가 큰 선회각들도 많이 찾을 수 있습니다. 그러나 현재의 평가함수는 가장 작은 5개의 선회각을 제외하고는 평가에 반영하지 않기 때문에, 좋은 해를 버리는 악효과가 발생합니다. 이런 해들을 잘 활용해서 평가함수를 좀 더 효율적으로 짤 수는 없을까요?\\\r\n한 가지 방법은, 어떤 기준각을 잡아 놓고 그 크기가 기준각보다 더 큰 선회각의 개수를 평가함수로 지정하는 것입니다. 그러면 큰 각들은 최대한 유지하면서 작은 각의 크기를 키워나갈 수 있을 것입니다. 그러나, 이렇게 하면 가장 작은 각을 키우기는 더 어려워질 것입니다.\\\r\n가장 작은 각과 큰 각들을 모두 평가함수에 반영할 수 있도록 해봅시다. 기준각보다 크기가 큰 선회각의 경우 '만점 점수'에 해당하는 점수를 주고($X$라 합시다), 그렇지 않은 경우 선회각에서 기준각을 뺀 값(당연히 음수입니다)를 줍니다. 이들을 모두 합한 것을 평가함수로 두어 봅시다.\\\r\n이렇게 하면, (물론 더 복잡해진 것 같지만,) 한 번의 경로 교환 당 바뀌는 각의 크기는 최대 4이므로 평가함수를 상수 시간으로 구현할 수 있습니다.\\\r\n이를 이용하여, 테스트케이스별로 만점 점수 $X$에 입력되는 변수 $Z_0$보다 2에서 3 정도 낮은 값을 대입하면 $O(10^8)$ ~ $O(10^9)$ 사이에서 90점 이상의 점수를 얻을 수 있습니다.\r\n### 아이디어 9: 해의 다양성에 대해서\r\n조금 더 높은 점수를 목표로 해 봅시다. 기존에는 평가함수의 값이 높아지거나 같을 경우 경로해를 변경했습니다. 그러나 조금 더 다양한 해를 탐색할 수 있도록, 평가함숫값이 조금은 내려가는 경우에도 이를 새로운 해로 적용합시다. 이 역시도, 적절한 변수 $Y$를 잡아 평가함숫값이 $Y$배 이상으로 변하는 경우 해로 적용할 수 있습니다. 이렇게 하면, 동일한 연산 횟수에 대해 2점 정도 더 높은 점수를 받을 수 있습니다.\r\n### 아이디어 10: 더 높은 점수를 향해\r\n사실 이 문제에서 만점을 받기는 굉장히 어렵습니다. 풀이 작성자인 저의 경우, DP를 이용해 해결한 1번 테스트케이스를 제외하면 2번에서 171402096849($=O(1e11)$)회, 3번에서 1497594757($=O(1e9)$)회, 4번에서 36891708048($=O(3e10)$)회, 5번에서 12563420022($=O(1e10)$)회의 연산을 통해 만점 해를 계산해내었습니다. *물론 각 연산은 경로 수정과 평가함수 구동 모두를 동반하기 때문에, 대략 400만 회 연산 당 1초로 계산하는 것이 더 적절합니다.*\r\n#### 아이디어 11: 테스트케이스 6번에 대해서\r\n테스트케이스 6번은 각 지점들이 동심원 약 20개 중 하나의 위에 균등하게 분포하여 있는 테스트케이스입니다. 이 경우 20개의 동심원이 각각 하나의 사이클으로 형성되면 사이클을 없애는 과정에서 최소 선회각이 더 작아질 확률이 많이 높아집니다. 따라서, 아예 초기해를 그리디 알고리즘의 해가 아닌 무작위 수열으로 두는 것을 시도할 수 있겠습니다.\\\r\n이를 고려하면서 동일한 코드를 구현하면, (2~5번 테스트케이스보다는) 비교적 매우 짧은 시간 내에 만점을 받는 해를 찾을 수 있습니다.\r\n\r\n이제 할 수 있는 방법은, $X$와 $Y$의 변숫값을 잘 조절해가면서 인내심을 가지고 코드가 해를 찾을 때까지 기다리는 것입니다. 원하신다면 [이 링크](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day1/aerobatics-sample.cpp)에서 문제의 정해 풀이와 **출제자의 최적 변숫값**을 확인할 수 있습니다. 그러나 여기까지 따라오셨다면 변숫값을 조절하여 적당하게 해를 뽑아내는 것은 충분히 할 수 있다고 봅니다.\\\r\n2-opt의 최적화를 기반으로 한 TSP 풀이만으로 이 문제를 풀 수 있지는 않습니다. 담금질 기법이나 DLAS 등의 더 효율적인 휴리스틱 알고리즘을 통해 더 빠르게, 혹은 더 높은 점수를 받는 해를 찾을 수 있을지도 모릅니다. 이것은 여러분께 맡기겠습니다.\\\r\n아무튼, 이 단계까지 오셨다면 기범이의 완벽한 비행을 위해서 꼭 100점 완성에 성공하셨으면 합니다."}]}
-->