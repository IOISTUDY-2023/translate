# Aerobatics (JOISC 2021)

## 문제
기범이는 곡예비행 대회에 출전해서 비행기를 조종하려고 한다. 비행기는 일정한 고도를 날며 N개의 지점을 통과해야 한다. 각 지점은 $1$부터 $N$까지의 번호를 가지고 있다. 이때 $i$번 지점($1 \leq i \leq N$)은 좌표 $(X_i,Y_i)$에 위치해 있다.

기범이는 비행기를 타고 모든 지점을 $1$번씩 통과해야 한다. 더 엄밀히 설명하면 다음과 같다.
1. $N$개의 지점 중 처음 출발할 지점 하나를 선택한다. 이 지점은 이미 방문한 것으로 간주한다.
2. 다음을 $N-1$회 반복한다. 아직까지 방문하지 않은 지점 중 지점 $1$개를 선택하여, 현재 비행기가 위치한 지점부터 선택한 지점까지 직선으로 날아간다.
3. 2.를 모두 수행하여 $N$번째 지점에 도달하면 비행이 끝난다.

2.에서, 비행기는 지점에서 지점으로 날 때마다 항상 일직선으로 비행해야 한다. 이렇게 하면, 기범이가 비행하는 경로는 선분 $N-1$개와 각 $N-2$개로 이루어진 도형이 된다.

이때, 한 점에서 만나는 두 선분 경로 사이의 각이 작으면 비행기의 방향 변화가 크기 때문에 비행에 실패할 확률이 더 크다. 때문에, 기범이는 $N-2$개 각의 크기 중 최솟값이 최대가 되도록 경로를 설정하려고 한다.

각 지점의 좌표가 주어질 때, 각의 크기의 최솟값이 최대가 되게 하는 지점 방문 순서를 계산하는 프로그램을 작성하여라.

## 입력
첫째 줄에 지점의 수 $N$과 변수 $Z_0$가 주어진다. $Z_0$은 그레이더에서 사용하는 변수이다.
둘째 줄부터 $N$개의 줄에 각 지점의 좌표 $X_i$, $Y_i$가 주어진다.

## 출력
$i$번째 줄에 $i$번째로 방문할 지점의 번호를 출력한다. $(1 \leq i \leq n)$

## 제한
* $3 \leq N \leq 1000$
* $\sqrt{Xi^2+Yi^2} \leq 10000000$ $(1 \leq i \leq N)$
* $(X_i, Y_i) \neq (X_j, Y_j)$ $(1 \leq i < j \leq N)$
* $1 \leq Z_0 \leq 179$
점수 탭에서 6개의 입력 데이터를 모두 다운받을 수 있다.

## 라이브러리
이 문제에서 여러분은 세 점이 이루는 각의 크기를 계산하는 함수를 사용할 수 있다. 라이브러리는 [첨부파일](https://upload.acmicpc.net/c797d43d-2a9d-4dfe-83d6-73f56495a8a0/)의 aerobatics.h 파일에 저장되어 있다. 함수는 다음과 같이 사용할 수 있다.
```c++
double GetAngle(int xa, int ya, int xb, int yb, int xc, int yc)
```
본 함수는 각 $BAC$를 도(degree) 단위로 계산한다. 반환값은 double 형식의 실수이며, 오차는 매우 작다.\
$xa$, $ya$는 점 $A$의 좌표, $xb$, $yb$는 점 $B$의 좌표, $xc$, $yc$는 점 $C$의 좌표이다.\
점 $A$와 $B$가 같거나 점 $A$와 $C$가 같을 경우 함수의 정상 작동을 보장하지 않는다.\
제출하는 코드에서 GetAngle 코드를 사용할 수 있다. 이 함수는 그레이더에서 사용하는 함수와 동일하다. 다만, 필요한 경우 함수를 수정하여 사용해도 좋다.
> BOJ에서는 총 6개의 입력 데이터별로 출력 결과를 따로 받고 있다. 따라서 답안을 text로 제출하여도 된다.

## 점수
각 입력에 대해, 점수는 다음과 같이 계산된다.
출력이 틀릴 경우, 즉 출력 형식이 잘못되었거나 출력한 $N$개의 수가 $1$부터 $N$까지의 수를 하나씩 포함하고 있지 않은 경우, 0점을 받게 된다.
그렇지 않다면, 점수를 다음과 같이 계산한다.
$N-2$개의 각 중 최솟값을 $Z$라고 하자. $Z \geq Z_0$인 경우 점수 $S$를 받게 되며, $Z < Z_0$인 경우 $S*f(Z/180)/f(Z_0/180)$만큼의 점수를 받게 된다. 이때 $f(x)$는 정의역이 $[0,1]$인 함수로 $f(x)=4x^4+x$이다.
받는 점수의 총합은 6개의 입력 데이터에 대한 점수의 합을 반올림한 값이다. 6개의 입력 데이터는 다음과 같다.
* 1번 : [input_01.txt](http://upload.acmicpc.net/619e6ddd-dbf6-4cea-b0f8-9e8d69c1542c/), $N = 15$, $Z_0 = 100$, 10점
* 2번 : [input_02.txt](http://upload.acmicpc.net/858c84c9-be53-4157-9fd7-7b50f65f612a/), $N = 200$, $Z_0 = 143$, 15점
* 3번 : [input_03.txt](http://upload.acmicpc.net/4ac96dfd-9adc-4a13-8525-d873298a90ba/), $N = 200$, $Z_0 = 134$, 15점
* 4번 : [input_04.txt](http://upload.acmicpc.net/5db94ea0-5d12-47ae-8155-845c1d1d5bb0/), $N = 1000$, $Z_0 = 156$, 20점
* 5번 : [input_05.txt](http://upload.acmicpc.net/3af3ef7e-1322-4e01-b7c7-afbfd866670e/), $N = 1000$, $Z_0 = 150$, 20점
* 6번 : [input_06.txt](http://upload.acmicpc.net/c3388e76-ac0f-4f3e-bced-86b61c5b0bc0/), $N = 1000$, $Z_0 = 153$, 20점

## 예제
### 입력
```
7 90
3 1 
2 5 
0 2 
-1 6
-3 1
-1 -4
4 -2
```

### 출력
```
5
3
1
7
6
4
2
```

### 설명
비행기가 5, 3, 1, 7, 6, 4, 2 순으로 비행할 경우, 최소각은 6번 지점에 있으며 이 각의 크기는 68.19이다. $Z_0 = 90$ 이므로, 예제와 같이 출력하면 만점의 61.5%에 해당하는 점수를 받게 된다.

## 해설
본 문제는 Output-only 문제로, 주어진 6개의 테스트케이스에 대해서 조건에 맞게 적절한 해를 찾아 얻을 수 있는 출력만을 제출하면 되는 문제입니다.\
또한, 비행 경로의 최소각의 크기에 따라서 점수를 부여받기 때문에 완벽한 해를 찾을 필요 없이 대략적으로 답을 출력하면 됩니다.
### 테스트케이스 1에 대한 논의
지점의 수가 15개이기 때문에, 대충 Bitmask DP를 돌아보면 최적해를 구할 수 있습니다. 
### 풀이법 1: 무작위화하여 방문하기
적당한 경로를 제시하면 부분점수를 받을 수 있으므로, 그냥 주어진 지점들을 무작위하게 정렬해서 출력하는 것을 시도할 수 있습니다. 예를 들어, 출제진은 다음과 같은 해를 무작위하게 얻을 수 있었습니다:\
insert table here\
위와 같이 얻은 점수는 7점입니다. 더 높은 점수를 받는 것도 물론 가능하겠지만 아마 무작위한 방법만으로는 많은 시도가 필요할 것입니다.
### 풀이법 2: 그리디 알고리즘
여기서부터는, 두 선분 경로 사이의 각을 '선회각'이라고 합시다.\
처음 두 점을 적절하게 고른 뒤, 갈 수 있는 곳 중에 가장 선회각이 180도에 가깝도록 다음 지점을 선택하는 방법을 시도할 수 있습니다.\
이 풀이법을 이용하면 다음과 같은 경로를 얻을 수 있습니다:\
insert pic here\
처음 두 점을 잡는 방법으로는 여러 가지가 있을 수 있습니다. 예를 들어서, 첫 번째 지점은 x좌표가 가장 큰 점으로, 두 번째 지점은 첫 번째 지점과 이루는 경로가 y축과 이루는 각이 가장 작은 점으로 설정할 경우 6개 테스트케이스에서 총 14점을 획득할 수 있고, 처음 두 개의 점 조합을 모두 계산한다면 총 28점을 획득할 수 있습니다. \
이때 시간복잡도는 $O(N^4)$이므로, $N = 2000$인 테스트케이스의 경우 각각 20분 정도를 소요해야 해를 얻을 수 있습니다. 컴퓨터를 한 시간 넘게 혹사시킨 것 치고는 그리 만족스럽지 못한 점수인 것 같습니다.
### 풀이법 3: Hill Climbing
Hill Climbing 방법은 