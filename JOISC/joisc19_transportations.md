# Two Transportations

## 문제

JOI 국가에는 $N$개의 도시가 있어 $0$에서 $N-1$까지 번호가 매겨져 있다. $A$개의 철도 노선도 있어 $0$에서 $A-1$까지 번호가 매겨져 있다. 철도 노선 $i \quad (0 \leq i \leq A - 1)$는 도시 $U_i$와 도시 $V_i$를 양방향으로 연결하며, 비용은 $C_i$이다. 서로 다른 철도 노선은 서로 다른 쌍의 도시를 연결한다. $B$개의 버스 노선도 있고, $0$에서 $B - 1$까지 번호가 매겨져 있다. 버스 노선 $j \quad (0 \leq j \leq B - 1)$는 도시 $S_j$와 도시 $T_j$를 양방향으로 연결하며, 요금은 $D_j$이다. 서로 다른 버스 노선은 서로 다른 쌍의 도시를 연결하지만, 철도 노선과 버스 노선이 같은 쌍의 도시를 연결할 수도 있다. 철도 및 버스를 이용하여 어떤 쌍의 도시 사이라도 이동할 수 있음이 보장된다.

Azer는 도시 $0$에서 각 도시로 이동하는 데 필요한 최소 요금을 알고 싶어한다. 철도 노선만 알고 있는 Azer은 버스 노선만 알고 있는 Baijan과 협력한다.

Azer와 Baijan 두 사람은 문자 $0$ 또는 $1$을 주고받으며 서로 통신한다. 전송된 문자의 총 개수는 $58,000$보다 작거나 같아야 한다.

철도 노선의 정보가 주어진 Azer의 프로그램과 버스 노선의 정보가 주어진 Baijan의 프로그램이 서로 통신하여, Azer가 도시 $0$으로부터 각 도시로 이동하는 데의 최소 비용을 모두 구하라.

## 구현

두 개의 파일을 제출해야 한다.

첫번째 파일의 이름은 Azer.cpp이다. 이는 Azer의 행동을 나타내고, 다음과 같은 함수를 구현해야 한다. 이 파일은 Azer.h를 포함해야 한다.

* void InitA(int N, int A, std::vector<int> U, std::vector<int> V, std::vector<int> C)
  
  이 함수는 최초에 정확히 한 번 실행된다.
  
  - 매개변수 $N$은 $N$으로, 도시의 개수이다.
  
  -  매개변수 $A$는 $A$로, 철도 노선의 개수이다.
  
  -  매개변수 $U, V$ 은 길이가 $A$인 배열이다. $U[i]$와 $V[i]$는 $U_i$와 $V_i$로, 철도 노선 $i$가 연결하는 도시이다 $(0 \leq i \leq A − 1)$.

 - 매개변수 $C$는 길이가 $A$인 배열이다. $C[i]$는 $C_i$로, 철도 노선 $i$의 비용이다 $(0 \leq i \leq A − 1)$.

* void ReceiveA(bool x)
  
  이 함수는 Baijan에게 문자 하나를 받을 때마다 실행된다.
  
  - 매개변수 $x$는 Baijan에게 받은 문자를 나타낸다: true는 문자 $1$, false는 문자 $0$.
  
* std::vector<int> Answer()
  
  이 함수는 보낸 모든 문자를 받았을 때 정확히 한 번 실행된다. 이 함수는 도시 $0$으로부터 각 도시로 이동하는 데에 필요한 최소 비용을 담은 배열 $Z$를 반드시 반환해야 한다.
  
  - 반환값 $Z$는 길이가 $N$인 배열이어야 한다. 그 길이가 $N$이 아니라면, 당신의 프로그램은 Wrong Answer [1]로 채점된다. $Z[k] \quad (0 \leq k \leq N − 1)$는 도시 $0$으로부터 도시 $k$로 이동하는 데에 필요한 최소 비용이어야 한다. 특히, $Z[0]=0$을 반드시 만족해야 함에 유의하라.

이 프로그램은 다음과 같은 함수를 호출할 수 있다.
  
* void SendA(bool y)
  
  이 함수를 통해 Baijan에게 문자 하나를 보낸다.
  
  - 매개변수 y는 Baijan에게 보내는 문자를 나타낸다: true는 문자 1, false는 문자 0.

두번째 파일의 이름은 Baijan.cpp이다. 이는 Baijan의 행동을 나타내고, 다음과 같은 함수를 구현해야 한다. 이 파일은 Baijan.h를 포함해야 한다.

* void InitB(int N, int B, std::vector<int> S, std::vector<int> T, std::vector<int> D)
  
  이 함수는 최초에 정확히 한 번 실행된다.
  
  - 매개변수 $N$은 $N$으로, 도시의 개수이다.
  
  - 매개변수 $B$는 $B$로, 버스 노선의 개수이다.
  
  - 매개변수 $S, T$는 길이가 $B$인 배열이다. $S[j]$와 $T[j]$는 $S_j$와 $T_j$로, 버스 노선 $j$가 연결하는 두 도시이다 $(0 \leq j \leq B − 1)$.
  
  - 변수 $D$는 길이가 $B$인 배열이다. $D[j]$는 $D_j$로, 버스 노선 $j$의 비용이다 $(0 \leq j \leq B − 1)$.

* void ReceiveB(bool y)
  
  이 함수는 Azer에게 문자 하나를 받을 때마다 실행된다.
  
  - 매개변수 $y$는 Azer에게 받은 문자를 나타낸다: true는 문자 $1$, false는 문자 $0$.

이 프로그램은 다음과 같은 함수를 호출할 수 있다.

* void SendB(bool x)
  
이 함수를 통해 Azer에게 문자 하나를 보낸다.
  
매개변수 $x$는 Azer에게 보내는 문자를 나타낸다: true는 문자 $1$, false는 문자 $0$.

프로그램이 다음과 같이 실행된다고 가정할 수 있다. 각 테스트 케이스에 대하여, 두 개의 queue가 준비되어 있다: Azer이 보낸 문자가 저장되는 QY, Baijan이 보낸 문자가 저장되는 QX. 먼저, InitA와 InitB가 실행되고, 보낸 문자는 해당하는 큐에 push 된다.

* 만약 QX와 QY 중 하나라도 비어있지 않다면, 문자 하나는 그 큐로부터 pop 되어 ReceiveA 또는 ReceiveB가 호출된다. 그러나, 만약 QX와 QY가 둘 다 비어있지 않다면, ReceiveA와 ReceiveB 중 어느 것이 호출될지 정해져있지 않다.
  
* SendA가 ReceiveA의 실행 중 호출되면, 보낸 문자는 QY에 push 된다.
  
* SendB가 ReceiveB의 실행 중 호출되면, 보낸 문자는 QX에 push 된다.
  
* 만약 두 개의 큐가 모두 비어있다면, Answer이 호출되고 프로그램이 종료된다.
  
Azer과 Baijan이 보낸 문자의 총 개수는 58000보다 작거나 같아야 한다. 만약 더 크다면, 프로그램은 Wrong Answer [2]로 채점된다.

## 중요 공지
  
* 프로그램은 내부 사용 목적의 다른 함수를 구현하거나 전역 변수를 사용할 수 있다. 제출된 파일은 그레이더와 함께 컴파일되어 하나의 실행 파일이 된다. 모든 전역 변수와 내부 함수는 다른 파일과의 충돌을 방지하기 위해 이름이 지정되지 않은 네임스페이스에 선언되어야 한다. 그레이딩이 완료되면 Azer와 Baijan의 두 프로세스로 실행된다. Azer의 프로세스와 Baijan의 프로세스는 전역 변수를 공유할 수 없다.
  
* 프로그램은 표준 입력과 표준 출력을 사용해서는 안 된다. 프로그램은 어떤 방법으로도 다른 파일과 통신해서는 안 된다. 단, 프로그램에서 디버깅 정보를 표준 오류로 출력할 수는 있다.

## 컴파일 및 테스트 실행
  
웹페이지에서 샘플 그레이더가 포함된 아카이브 파일을 다운로드하여 프로그램을 테스트할 수 있다. 아카이브 파일에는 프로그램의 샘플 소스 파일도 포함되어 있다. 샘플 채점기는 grader.cpp 파일이다. 프로그램을 테스트하려면 grader.cpp, Azer.cpp, Baijan.cpp, Azer.h, Baijan.h를 같은 디렉터리에 넣고 다음 명령을 실행하여 프로그램을 컴파일해야 한다.
  
g++ -std=gnu++14 -O2 -o grader grader.cpp Azer.cpp Baijan.cpp 
  
컴파일에 성공하면 실행 파일 그레이더가 생성된다.
  
실제 그레이더는 샘플 그레이더와 다르다는 점에 유의하라. 샘플 그레이더는 표준 입력에서 입력 데이터를 읽고 그 결과를 표준 출력과 표준 오류에 출력하는 단일 프로세스로 실행된다.

## 샘플 그레이더의 입력

샘플 그레이더는 다음과 같은 형식의 입력 데이터를 표준 입력으로 입력받는다.

$N \quad A \quad B$
  
$U_{0} \quad V_{0} \quad C_{0}$
  
$\vdots$
  
$U_{A−1} \quad V_{A−1} \quad C_{A−1}$
  
$S_{0} \quad T_{0} \quad D_{0}$

$\vdots$
  
$S_{B−1} \quad T_{B−1} \quad D_{B−1}$

## 샘플 그레이더의 출력
  
샘플 그레이더는 표준 출력과 표준 오차(명확성을 위해 따옴표로 표기)에 다음 정보를 출력한다.
  
* 프로그램이 Wrong Answer [1] 또는 Wrong Answer [2]로 판정된 경우 해당 유형을 표준 오류에 "Wrong Answer [1]"로 기록한다. 표준 출력에는 아무것도 출력하지 않는다.
  
* 그렇지 않으면 표준 오류에 전송된 문자의 총 개수 $L$을 "Accepted: $L$"로 표준 오류에 출력한다. 또, 다음과 같이 표준 출력에 답안 $Z$를 출력한다:
  
$Z[0]$

$\vdots$

$Z[N - 1]$
  
샘플 그레이더는 $Z$의 값이 올바른지 확인하지 않는다.

프로그램이 여러 유형의 Wrong Answer로 판정된 경우 샘플 채점기는 그 중 하나만 보고한다.


## 제한
  
* $1 \leq N \leq 2000$
  
* $0 \leq A \leq 500000$
  
* $0 \leq B \leq 500000$
  
* $0 \leq U_{i} \leq N − 1 \quad (0 \leq i \leq A − 1)$
  
* $0 \leq V_{i} \leq N − 1 \quad (0 \leq i \leq A − 1)$
  
* $U_{i} , V_{i} \quad (0 \leq i \leq A − 1)$
  
* $(U_{i_1}, V_{i_1}) , (U_{i_2}, V_{i_2})$ and $(U_{i_1}, V_{i_1}) , (V_{i_2}, U_{i_2}) \quad (0 \leq i_{1} < i_{2} \leq A − 1)$
                                                                                                            
* $0 \leq S_{j} \leq N − 1 \quad (0 \leq j \leq B − 1)$
                                                                                                            
* $0 \leq T_{j} \leq N − 1 \quad (0 \leq j \leq B − 1)$
                                                                                                            
* $S_{j} , T_{j} \quad (0 \leq j \leq B − 1)$
                                                                                                            
* $(S_{j_1}, T_{j_1}) , (S_{j_2}, T_{j_2})$ and $(S_{j_1}, T_{j_1}) , (T_{j_2}, S_{j_2}) \quad (0 \leq j_{1} < j_{2} \leq B − 1)$
  
* 철도 및 버스를 이용하여 임의의 두 도시 사이를 이동할 수 있음이 보장된다.
  
* $1 \leq Ci \leq 500 \quad (0 \leq i \leq A − 1)$
  
* $1 \leq Dj \leq 500 \quad (0 \leq j \leq B − 1)$

## 서브태스크
  
1. (6점) $A = 0$
  
2. (8점) $B \leq 1000$
  
3. (8점) $A + B = N − 1$
  
4. (38점) $N \leq 900$
  
5. (14점) $N \leq 1100$
  
6. (10점) $N \leq 1400$
  
7. (16점) 추가 제한이 없다.
  
# 해설

## 서브태스크 1
$A=0$으로, 모든 교통수단의 정보는 Baijan이 알고 있다. 따라서 적절한 알고리즘을 사용하여 Baijan이 도시 $0$으로부터 다른 모든 도시로의 최소 비용을 구한 후, 이를 Azer에게 보내면 된다.
  
Dijkstra 알고리즘을 이용하면 시간복잡도 $O((N+B)\log{B})$에 가능하다. $N \leq 2000 <2^{11}$, $\text{가중치} \leq 500 < 2^{9}$, $\text{최소 비용} <2^{20} $이므로 정점 번호 순서로 거리를 보내면 $1999 \times (11+9) = 39980$비트를 사용한다.

## 서브태스크 2
$B \leq 1000$으로, Baijan 쪽의 정보 개수가 적기 때문에 이 정보를 모두 Azer에게 보낸다.

$S[j] \leq 2000 < 2^{11}, T[j] \leq 2000 < 2^{11}, D[j] \leq 500 < 2^{9}$로 $(S[j], T[j], D[j])$를 보내는 데에는 $1000 \times (11+11+9) = 31000$비트를 사용한다.

## 서브태스크 3
$A+B=N-1$로, 주어진 그래프가 트리 그래프임을 의미한다. 서브태스크 2와 유사하게, Baijan이 가진 정보를 모두 Azer에게 보낸다. 단, 서브태스크 2처럼 할 수는 없다.

$k$번째로 정보를 보낼 때 정점 $k$와 함께 트리 그래프의 간선을 구성하는 반대편 정점에 대해 $(\text{반대편 정점}, \text{가중치})$를 보낸다. 이러면 $1999 \times (11+9) = 39980$비트를 사용한다.

## 서브태스크 4
$N \leq 900$으로, 그래프의 특성과 관련 없는 일반적인 풀이가 필요하다.

Dijkstra 알고리즘의 작동 방식을 잘 생각해보자. Dijkstra의 각 단계에서 Azer와 Baijan이 아직 방문하지 않은 정점 중 비용이 최소인 정점에 대해 서로 $(\text{정점 번호}, \text{비용})$의 정보를 보내면 그래프 전체에서 Dijkstra의 현재 단계에서 방문해야 할 정점을 알 수 있고, 따라서 두 사람이 협동하여 Dijkstra 알고리즘을 돌릴 수 있다.

Dijkstra의 한 단계에서 $(\text{정점 번호}, \text{비용})$의 정보를 보낼 때 $(20+11) \times 2 = 62$비트를 사용한다. 이 방법으로 해결할 수 있는 $N$의 범위를 생각해보면 대략 $58000/62 \approx 935$까지 처리할 수 있다. 따라서 이 방법으로 서브태스크 4를 해결할 수 있다.

## 서브태스크 5
서브태스크 4의 방법을 개선한다. Dijkstra의 각 단계에서 방문해야 할 정점을 결정할 때, Azer와 Baijan이 각각 비용에 대한 정보를 먼저 보낸 다음, 둘 중 비용이 작은 쪽이 정점 번호를 보낼 수 있다. 이러면 정점 하나에 해당하는 비트를 아낄 수 있으므로, 이를 서브태스크 4의 풀이에 적용하면 Dijkstra의 한 단계에서 사용하는 비트는 $20 \times 2 + 11 = 51$비트이다. 이 방법으로 $N$이 대략 $58000/51 \approx 1137$일 때까지 처리할 수 있으므로, 서브태스크 5를 해결할 수 있다.

## 서브태스크 6
서브태스크 4의 방법을 개선한다. Dijkstra의 각 단계에서 방문할 정점을 결정할 때 비용에 대한 정보를 보내는 과정에서 비트를 많이 사용하므로, 이를 줄이는 방법에 대해 생각한다. 비용을 보낼 때, 비용의 값을 직접 보내지 말고, 이전에 보냈던 비용과의 차 값을 보낸다. 새로이 갱신되어 보내는 비용은 간선 하나의 비용인 500 이하이기 떄문에, 이를 서브태스크 4의 풀이에 적용하면 Dijkstra의 한 단계에서 사용하는 비트는 $(9+11) \times 2 = 40$비트이다. 이 방법으로 $N$이 대략 $58000/40 \approx 1450$일 때까지 처리할 수 있으므로, 서브태스크 6을 해결할 수 있다.

## 서브태스크 7(전체 문제)
서브태스크 4의 방법에 서브태스크 5, 서브태스크 6에서의 개선 방법을 동시에 적용한다. 이러면 Dijkstra의 한 단계에서 사용하는 비트는 $9 \times 2 + 11 = 29$비트이다. 이 방법으로 $N$이 $58000 / 29 = 2000$일 때까지 해결할 수 있으므로, 전체 문제를 해결할 수 있다.
