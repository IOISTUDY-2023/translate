# Navigation 2(joisc 2021)
# 문제
JOI 왕국은 바다로 둘러싸인 섬입니다. JOI Kingdom의 땅은 N개의 행과 N개의 열로 구성된 정사각형 격자의 그리드입니다. 세로 방향은 남북 방향이고 가로 방향은 서동 방향입니다.
북쪽에서 $(r + 1)$번째 행 $(0 ≤ r ≤ N − 1)$과 서쪽에서 $(c + 1)$번째 열 $(0 ≤ c ≤ N − 1)$에 있는 격자를 격자 $( r, c)$라고 부릅니다.      
<br/> JOI 왕국의 여왕 Anna는 Bruno를 파티에 초대합니다. 그녀는 지금 파티 장소를 선택하고 있습니다. 그녀는 $K(=7)$개의 파티가 열릴 가능성이 있는 후보 격자들을 선택했습니다.      
후보 격자는 0부터 $K-1$까지 번호가 매겨진다. i번째 후보격자는 격자 $(R_i, C_i)$이다. 모든 후보 격자는 바다에 인접하지 않았습니다.
파티 장소는 파티 당일 결정됩니다.      
<br/>파티 전날, Anna는 Bruno가 길을 잃지 않고 파티 장소에 도착할 수 있도록 모든 격자에 깃발을 꽂을 것입니다. 각 깃발에 Anna는 1에서 1,000,000,000 사이의 정수를 씁니다.      
파티 당일에는 후보 격자의 인덱스 $t(0 ≤ t ≤ K − 1)$만 Bruno에게 알려줍니다. 그 후 Bruno는 헬리콥터를 타고 바다와 인접하지 않은 격자에 도착합니다. 그런 다음 Bruno는 파티 장소로 이동하기 시작합니다.
Bruno는 자신이 어디에 있는지 모르지만 동서남북 방향은 알고 있습니다. Bruno는 현재 셀과 주변 8개 격자에서만 깃발을 볼 수 있습니다.       
<br/> 즉, Bruno가 격자 $(a, b)(1 ≤ a ≤ N − 2, 1 ≤ b ≤ N − 2)$에 있을 때 다음 9개 격자의 플래그만 볼 수 있습니다.      
 $(a - 1, b - 1), (a - 1, b), (a - 1, b + 1), (a, b - 1), (a, b), (a, b + 1), (a + 1, b - 1), (a + 1, b), (a + 1, b + 1)$      
<br/> 브루노는 다음 5가지 행동 중 하나를 취할 수 있습니다.      
+ 행동 0: Bruno는 동쪽으로 한 칸 이동합니다. 즉, 격자 $(a, b)$에서 격자 $(a, b + 1)$로 이동합니다.   
+ 행동 1: Bruno는 서쪽으로 한 칸 이동합니다. 즉, 격자 $(a, b)$에서 격자 $(a, b − 1)$로 이동합니다.   
+ 행동 2: Bruno는 남쪽으로 한 칸 이동합니다. 즉, 격자 $(a, b)$에서 격자 $(a + 1, b)$로 이동합니다.   
+ 행동 3: Bruno는 북쪽으로 한 칸 이동합니다. 즉, 격자 $(a, b)$에서 격자 $(a − 1, b)$로 이동합니다.   
+ 행동 4: Bruno는 파티가 현재 자신의 격자에서 열릴 것이라고 생각하고 거기에 머뭅니다. 즉, 그는 움직이지 않습니다.   
<br/> 파티에 늦게 도착해선 안되기 때문에 Bruno는 가능한 한 행동의 수를 최소화하면서 파티 장소로 이동해야 합니다. 따라서, 이런 조건하에 Bruno는 바다에
인접한 격자에 절대 들어가지 않습니다.   
<br/> 깃발에 큰 정수를 쓰는 것은 번거롭기 때문에 Anna는 깃발에 쓰는 최대 정수를 최소화하려고 합니다.
<br/> Anna의 전략과 Bruno의 전략을 구현하는 프로그램을 작성하십시오. Anna는 깃발에 정수를 적고 Bruno는 최소한의 행동으로 파티 장소에 도착해야합니다.
# 구현
총 2개의 파일을 구현해야 합니다.   
<br/> 첫 번째 파일은 Anna.cpp입니다. Anna의 전략을 구현해야 합니다. 다음 기능을 구현해야 합니다. 프로그램은 전처리 지시문 #include를 사용하여 Anna.h를 포함해야 합니다.   
<br/>
+ void Anna(int N, int K, std::vector<int> R, std::vector<int> C)   
+ 이 함수는 깃발에 정수를 쓰는 Anna의 전략을 구현합니다. 각 시나리오(스코어링 참조)에 대해 이 함수는 처음에 정확히 한 번 호출됩니다.   
+ 파라미터 N은 JOI 왕국의 땅이 N 행과 N 열로 구성된 정사각형 격자의 그리드임을 의미합니다.   
+ 파라미터 K는 파티의 후보 격자의 개수 $K(=7)$입니다.   
+ 파라미터 R과 C는 길이 K의 배열입니다. 여기서 R[i]와 C[i] $(0 ≤ i ≤ K − 1)$는 후보 셀 i의 셀 $(Ri, Ci)$을 나타냅니다.   
+ 파라미터 N, K, R[i] 및 C[i] $(0 ≤ i ≤ K − 1)$ 값의 범위는 제약 조건을 참조하십시오.   
+ Anna에 대한 각 함수 호출에 대해 다음 함수는 정확히 $N^2$번 호출되어야 합니다. 모든 격자에 대해 한 번씩 호출해야 합니다.   
<br/> void SetFlag(int r, int c, int value)
+ 파라미터 r 및 c는 Anna가 격자 $(r, c)$의 깃발에 정수를 쓴다는 것을 의미합니다. 여기서 $0 ≤ r ≤ N-1, 0 ≤ c ≤ N-1$을 만족해야 한다. 이 조건이 만족되지 않으면 프로그램이 오답[1]으로 판정됩니다.
+ 파라미터 value는 Anna가 깃발에 쓰는 정수입니다. 여기서 $1 ≤ value ≤ 1 000 000 000$을 만족해야 합니다. 이 조건이 만족되지 않으면 프로그램이 오답[2]으로 판정됩니다.
함수 SetFlag가 동일한 매개변수 $(r, c)$로 두 번 이상 호출되면 프로그램이 오답으로 판단됩니다[3].
Anna 함수가 종료될 때 SetFlag 함수에 대한 함수 호출 횟수가 $N^2$와 다르면 프로그램이 오답[4]으로 판단됩니다.   
SetFlag 함수에 대한 함수 호출이 오답으로 간주되면 프로그램이 즉시 종료됩니다.
+ 두 번째 파일은 Bruno.cpp입니다. 브루노의 전략을 구현해야 합니다. 다음 기능을 구현해야 합니다. 프로그램은 전처리 지시문 #include를 사용하여 Bruno.h를 포함해야 합니다.   
<br/> std::vector<int> Bruno(int K, std::vector<int> value) 
+ 이 함수는 Bruno의 다음 작업을 설명해야 합니다. 각 시나리오(스코어링 참조)에 대해 Anna 함수가 호출된 후 이 함수가 정확히 한 번 호출됩니다.
+ 파라미터 K는 파티의 후보 격자의 개수 $K(=7)$입니다.
+ 파라미터 value는 길이 9의 배열입니다. Bruno의 현재 격자와 주변 8개 격자의 깃발에 쓰여진 정수를 포함합니다. 보다 정확하게는 Bruno가 현재 깃발 $(a, b)$에 있는 경우 $(1 ≤ a ≤ N − 2, 1 ≤ b ≤ N − 2)$ value[0], value[1], . . . , value[8]은 $(a−1, b−1), (a−1, b), (a−1, b+1), (a, b−1), (a, b), (a, b+1), (a+1, b−1), (a+1, b), (a+1, b+1)$ 격자의 깃발에 쓰여진 정수입니다
+ 모든 $t = 0, 1, 2, . . . , K − 1$에 대해, 함수 Bruno는 파티가 후보 격자 t에서 개최될 때 Bruno의 다음 행동을 결정해야 합니다. 반환 값은 길이 K의 배열입니다. 배열의 $(i + 1)$번째 요소 $(0 ≤ i ≤ K − 1)$는 $t = i$에 대한 Bruno의 다음 동작이어야 합니다.
+ 반환 값이 길이 K의 배열이 아닌 경우 프로그램은 오답[5]으로 판단됩니다.
+ 배열의 모든 요소는 0, 1, 2, 3 또는 4 중 하나여야 합니다. 이 조건이 충족되지 않으면 프로그램이 오답으로 판단됩니다[6].
+ 매 t마다 Bruno 함수가 주는 행동이 Bruno의 다음 행동이 되어야만 최소한의 행동으로 파티 장소로 이동할 수 있습니다. 특히 그의 다음 행동이 행동 4라면 그의 현재 격자는 파티를 위한 장소여야 합니다. 이 조건이 만족되지 않으면 프로그램이 오답으로 판정됩니다[7]. 최소한의 액션으로 파티를 위한 장소로 이동하는 방법이 여러 가지라면 반환 값은 그 중 하나가 될 수 있습니다.   
<br/>
이 작업에서 각 테스트 사례는 Q 시나리오로 구성됩니다. 각 시나리오에서 Anna 함수와 Bruno 함수는 각각 정확히 한 번만 호출됩니다. 따라서 각 테스트 케이스에 대해 Anna 함수와 Bruno 함수를 각각 Q번이라고 합니다. 이러한 함수는 교대로 호출됩니다. 자세한 내용은 채점을 참조하십시오.
 
# 점수
 
각 테스트 케이스는 Q 시나리오로 구성됩니다. 시나리오는 0부터 $Q - 1$ 까지 번호가 지정됩니다. 각 시나리오에 대해 다음 값이 고정됩니다. 이러한 값의 범위는 제약 조건을 참조하십시오.
+ JOI 왕국의 세로 및 가로 크기 N.
+ 후보 격자의 수 $K(= 7)$.
+ 파티 장소의 후보 격자 $(R_0, C_0), (R_1, C_1), . . . , (R_{K-1}, C_{K-1})$.
+ 브루노의 현재 격자 $(a, b)$.
각 시나리오에 대해 Anna 함수가 호출됩니다. 주어진 파라미터에 대해 Anna는 깃발에 정수를 써야 합니다. 각 시나리오에 대해 Bruno 함수도 호출됩니다. 브루노의 다음 행동을 결정해야 합니다. Anna 함수와 Bruno 함수는 다음과 같은 방식으로 호출됩니다.

1. 각 $k = 0, 1, 2, . . . , Q − 1$에 대해, 순서대로 다음 2., 3.을 이 순서대로 수행한다.   
2. Anna 함수가 호출됩니다. 시나리오 k에 대한 매개변수는 구현 세부사항에서와 같이 제공됩니다.   
3. Bruno 함수가 호출됩니다. 시나리오 k에 대한 매개변수는 구현 세부사항에서와 같이 제공됩니다.   
이 과정에서 프로그램이 오답으로 판단되면 프로그램이 즉시 종료되며 테스트 케이스에 대한 오답으로 간주됩니다.
+ 프로그램이 테스트 사례 중 하나에서 오답으로 판단되면 이 작업에 대한 점수는 0점입니다.
+ 프로그램이 모든 테스트 사례에 대해 올바른 것으로 판단되면 이 작업에 대한 점수는 다음과 같이 계산됩니다. L을 모든 테스트 케이스 중에서 플래그에 기록된 최대 정수라고 합니다.   
 
+ $70 001 ≤ L ≤ 1 000 000 000$인 경우 점수는 7점입니다.
+ $10,001 ≤ L ≤ 70,000$이면 점수는 13점입니다.
+ $2,001 ≤ L ≤ 10,000$이면 점수는 19점입니다.
+ $21 ≤ L ≤ 2,000$인 경우 점수는 $50 − 12.5 × log10(L/20)$ 포인트이며 가장 가까운 정수로 내림됩니다.
+ $L ≤ 20$인 경우 점수는 다음 표와 같습니다.   
 
|L|20|19|18|17|16|15|14|13|≤12|
|---|---|---|---|---|---|---|---|---|---|
|점수|50|53|56|60|64|69|75|85|100|
 
# 제한
+ $1 ≤ Q ≤ 300$.
+ $5 ≤ N ≤ 100$.
+ $K = 7$.
+ $1 ≤ R_i ≤ N − 2 (0 ≤ i ≤ K − 1)$.
+ $1 ≤ C_i ≤ N − 2 (0 ≤ i ≤ K − 1)$.
+ $(R_i, C_i) ≠ (R_j, C_j) (0 ≤ i < j ≤ K − 1)$.
+ $1 ≤ a ≤ N − 2$.
+ $1 ≤ b ≤ N − 2$.

+ ## Subtask 1. ( $L=78125, 7점$)
우선, 기본적으로 어떤 파티장소와 같은 열에 있지 않다면 더 가까워지는 열 쪽으로, 만약 같은 열에 존재한다면 더 가까워지는 행 쪽으로 이동한다고 가정합니다. 그렇다면 각 파티장소의 위치에 대해서, 이동해야 하는 위치는 정확히 5가지 가능성을 가지고 있습니다. 그런데 파티장소는 최대 7곳이므로, 최대 $5^7$의 정수에 5진법을 활용하여 파티 장소의 방향을 저장할 수 있습니다. 따라서 L은 대략적으로 78125가 되고, 이는 7점에 해당합니다.

+ ## Subtask 2. ( $L=45056, 13점$)
모든 파티장소는 전부 다르기 때문에, 4번 행동, 즉 자신이 위치하는 격자에 정지하는 행동은 정확히 하나의 파티 장소에 대해서만 가능합니다. 이러한 점을 이용하여, 각 파티장소의 방향을 나타내는 배열이 가질 수 있는 모든 가짓수를 전부 계산한 다음, 이러한 수열에 해당되는 실제 인덱스를 보내면 Bruno의 입장에서도 동일한 계산을 통해 답을 복원할 수 있습니다.

+ ## Subtask 3. ( $L=2187, 19점$)
각 후보 장소들에 대해서, 해당 후보 장소까지의 택시 거리를 3으로 나눈 나머지를 각 셀에 기록한다고 생각합시다. 인접한 격자들중 법 3에 대해 그 값이 1 감소하는 격자가 존재한다면, 이는 실제 거리 또한 1만큼 감소했다는 사실을 알 수 있기 때문에, 해당 방향으로 이동하면 충분하다는 사실을 알 수 있습니다. 각 후보마다 총 3 가지 경우의 수를 가지는데, 후보 장소는 총 7개 존재하므로 L이 2187 이하가 되도록 문제를 해결할 수 있습니다.

+ ## Subtask 4. ( $L=128, 39점$)
각 후보 장소를 중심으로 하여, 격자들에 흰색과 검정색을 "아주 잘" 처리하면 어느 방향에 후보 장소가 존재하는지 확정이 가능해집니다. 자세한 컬러링 방식은 이미지를 첨부하여 나타내겠습니다.

+ ## Subtask 5. ( $L=14, 75점$)
+ 이전까지 사용한 모든 풀이는 하나의 격자에 모든 정보를 담아야 했기 때문에, 매우 비효율적이었습니다. 그러나, 현재 격자와 인접한 나머지 8개의 격자에 대한 정보 또한 알 수 있다는 점을 고려해보았을 때, 이는 명백한 낭비입니다. 따라서 해당 풀이에서는 하나의 격자에 하나 이하의 후보 장소의 정보를 담는 방식을 생각할 것입니다.
+ 우선, $(i,j)$번째 격자에 대해, i와 j가 전부 3의 배수인 경우에 0을 칠하도록 하겠습니다. $(i,j)$ 쌍에 대해서, 이 쌍들이 법 3에서 구분되는 것은 총 9개가 존재하며, 현재 법 3에 대해서 0인 하나의 격자를 소모했습니다. 따라서, 나머지 8개의 쌍들중 7개의 쌍들에 대해, 각각의 후보 장소와 매칭을 해줍니다. 이제 각 후보 장소에 대해, 다음과 같이 깃발에 정수를 칠하되, 반드시 정수가 칠해지는 깃발은 해당 후보 장소와 매칭된 쌍과 법 3에 대해 동일한 격자만이 되도록 합니다. 이렇게 하면 각 깃발에 1부터 13까지의 정수를 칠하게 되기 때문에, 우선 L이 14 이하라는 사실을 알 수 있습니다.
+ 해당 그림의 칠하는 방법을 구체적으로 말하자면, 한 후보 장소를 기반으로 인접한 격자들과 자기자신에 1~9까지 서로 다른 정수를 기록한 뒤, 자신과 가로로 1 이하 차이나는 격자들은 위-아래 구분에 따라 10,11을 칠하고, 나머지 격자들은 가로-세로에 따라 12,13을 칠합니다.
+ Bruno는 구체적으로, 자신이 볼 수 있는 모든 깃발들중, 0이 있는 깃발을 찾습니다. 해당 깃발을 찾음으로써, 자신이 위치한 격자의 법 3에 대한 값을 알 수 있게 되고, 각 격자가 어떤 후보 장소에 대한 내용을 담고 있는지 알 수 있습니다. 각각의 격자들에 적힌 숫자는 해당 후보 장소와 인접한 모든 격자들이 가야하는 동일한 방향을 알려주거나, 혹은 구체적으로 자신이 후보 장소에서 얼마나 멀리 떨어져 있는지 알 수 있도록 하는 정보들이기 때문에, 반드시 자신이 이동해야 하는 방향을 특정할 수 있습니다.

+ ## Subtask 6. ( $L=13, 85점$)
+ 잘 생각해보면, 현재까지 인접한 9칸중 총 8칸만을 사용하였으므로, 아직 낭비되고 있는 한 칸이 존재한다는 사실을 알 수 있습니다. 또 한가지 관찰할 수 있는 사실은, 1부터 9까지의 정수는 많아야 최대 7번 나온다는 사실입니다. 즉, 반드시 그 9개의 정수들중 적어도 하나는 등장하지 않습니다.
+ 이 사실들을 종합하여, 우리가 사용하지 않고 있는 마지막 한 칸에 한번도 등장하지 않은 정수를 칠하고, 해당 정수를 넘는 모든 정수들에 대해 1을 빼줍니다. 이 경우, 어떤 정수가 한번도 등장하지 않았는지 알 수 있으며, 1을 뺀 정수들도 전부 구분하여 다시 1을 더해줌으로써 Subtask 5의 상황을 복원할 수 있습니다. 이 경우, 사용하는 정수는 13개 이하가 됩니다.

+ ## Subtask 7. ( $L=12, 100점$)
+ 아직 우리가 사용하지 않은 사실은, 1부터 9 사이에 정수가 두 종류 이상 등장하지 않는다는 사실입니다. 즉, 나머지 하나의 수에 대한 정보를 담아야 합니다.
+ 만약 9가 사용되지 않도록 할 수 있다면, 10 이상의 모든 정수에서 1을 뺀 뒤 동일한 방식으로 복원하는 것이 가능합니다.
+ 사실, 모든 후보 장소들에 대해 9를 적도록 하는 칸은 많아야 7개라는 사실을 알 수 있고, 따라서 어떤 법 3에 대한 격자는 절대로 9가 등장하지 않습니다. 즉, 만약 처음에 0을 칠하는 위치를 적절히 설정한다면, 실제로 정수가 칠해지는 어떤 곳에도 9가 존재하지 않도록 할 수 있습니다.
+ 이 사실을 통해, 처음에 0을 칠하는 위치를 잘 설정하고 나면 9는 존재하지 않는다고 가정할 수 있고, 10 이상의 모든 정수들에서 1을 빼서 12종류의 수만을 사용해서 문제를 해결할 수 있습니다.
