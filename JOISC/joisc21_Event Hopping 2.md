# Event Hopping 2 - 행사 고르기 2 (JOISC2021)
## 문제
[BOJ](https://www.acmicpc.net/problem/21793), [oj.uz](https://oj.uz/problem/view/JOI21_event2), [atcoder](https://atcoder.jp/contests/joisc2021/tasks/joisc2021_k), [DMOJ](https://dmoj.ca/problem/joi21scd4p1), [LibreOJ](https://loj.ac/p/3496), [QOJ.ac](https://qoj.ac/problems?tag=JOISC%202021%20Day%204), [공식 문제지(영어)](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day4/event2-en.pdf), [공식 풀이 슬라이드(일어)](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day4/event2-review.pdf) 참고

경기과고에서 $N$개의 행사가 열릴 예정이다. 각 행사는 1번부터 $N$번까지의 번호를 가지고 있다. $i$번째 행사는 $L_i + 0.1$부터 $R_i - 0.1$까지의 시간 사이에 열린다. 이때 $L_i$와 $R_i$는 1 이상의 정수이다.\
건표는 이 중에서 정확히 $K$개의 행사에 참가하고자 한다. 행사가 시작된 후에 행사에 들어가거나, 종료되기 이전에 행사에서 나올 수는 없다. 참고로, 행사장 사이를 이동하는 시간은 무시한다.\
건표는 되도록 번호가 작은 행사에 참가하고 싶어한다. 더 엄밀히, 건표가 참가하려고 하는 행사의 번호가 $a_1, a_2, ..., a_N$(단, $a_1 < a_2 < ... < a_N$)일 때, 수열 $(a_1, a_2, ..., a_K)$가 사전순으로 가장 작은 수열이 되도록 하려고 한다.\
행사의 수와 각 행사의 시간, 건표가 참가하고자 하는 행사의 수가 주어졌을 때, 건표가 참가하고자 하는 행사의 번호를 출력하는 프로그램을 작성하시오.
## 입력
첫 번째 줄에는 행사의 수 $N$과 건표가 참가하고자 하는 행사의 수 $K$가 주어진다.\
두 번째 줄부터 $N$개의 줄에 걸쳐서 각 행사의 시작 시간 $L_i$와 종료 시간 $R_i$가 주어진다.\
입력받는 모든 수는 1 이상의 정수이다.
## 출력
$K$개의 줄에 걸쳐서 건표가 참가하고자 하는 행사의 번호를 출력한다. 이때, 가장 작은 번호부터 출력한다.\
만약 건표가 $K$개의 행사에 참가할 수 없다면, -1을 출력한다.
## 제한
- $1 \leq N \leq 100$ $000$
- $1 \leq K \leq N$
- $1 \leq L_i < R_i \leq 1$ $000$ $000$ $000$ ($1 \leq i \leq N$)
## 서브태스크
번호 | 배점 | 제한
--- | --- | ---
1 | 7 | $L_i \leq L_{i+1}$ ($1 \leq i \leq N-1$)
2 | 1 | $N \leq 20$
3 | 31 | $N \leq 3000$
4 | 61 | 추가 제한이 없다.
## 예제 입력 1
```
5 4
1 3
2 5
8 9
6 8
10 15
```
## 예제 출력 1
```
1
3
4
5
```
건표가 4개의 행사에 참여할 수 있는 방법은 다음과 같은 두 가지이다.
- 1, 3, 4, 5번
- 2, 3, 4, 5번

둘 중 사전순으로 더 작은 수열은 1, 3, 4, 5번이다.
## 예제 입력 2
```
4 3
1 4
3 5
4 9
7 10
```
## 예제 출력 2
```
-1
```
건표는 3개의 행사에 참여할 수 없다.
## 예제 입력 3
```
10 6
77412002 93858605
244306432 318243514
280338037 358494212
439397354 492065507
485779890 529132783
571714810 632053254
659767854 709114867
718405631 733610573
786950301 815106357
878719468 899999649
```
## 예제 출력 3
```
1
2
4
6
7
8
```
본 예제는 모든 서브태스크의 조건을 만족한다.
## 예제 입력 4
```
20 16
250732298 258217736
26470443 34965880
252620676 260043105
692063405 697656580
497457675 504191511
391372149 397942668
858168758 867389085
235756850 241022021
585764751 593366541
207824318 217052204
661682908 671226688
886273261 892279963
770109416 778960597
264372562 270395107
176883483 186662376
509929119 519063796
109491630 118520141
162731982 168101507
662727316 668317158
757072772 765493222
```
## 예제 출력 4
```
1
2
4
5
6
7
8
9
10
11
12
13
14
15
16
17
```

## 해설
- 여러 개의 구간이 있고, 주어지는 순서라는 우선 순위에 따라 겹치지 않도록 구간을 선택해야 합니다. 따라서, 만약 우선 순위가 빠른 구간을 선택할 수 있다면 무조건 그를 고르고 보는 것이 이득입니다.
### 서브태스크 1: 우선 순위와 구간 시작점의 순서가 동일한 경우
- 우선 순위가 곧 왼쪽입니다. 그냥 왼쪽부터 구간을 열심히 고르면 됩니다.
- 정렬되어 있는 구간의 집합에서 겹치지 않게 구간을 고르는 문제인데, 이러한 문제는 보통 현재 선택할 수 있는 구간 중 종점이 가장 왼쪽에 있는 것을 고르는 그리디를 사용하면 풀 수 있습니다. 
- 이런 그리디를 사용할 수 있는 이유는 그러한 구간과 다른 구간이 있을 때 그 다른 구간을 선택할 때 고를 수 있는 구간은 무조건 종점이 가장 왼쪽에 있는 구간을 선택해도 똑같이 고를 수 있기 때문입니다.
- 강의실 배정 문제와 비슷합니다. 구간 그래프를 최소 색상 채색할 때 다음 색을 그리디하게 뽑는 것처럼, 여기서는 다음 고를 구간을 그리디하게 뽑는 것입니다.
- 따라서, 입력된 순서대로 구간을 가지고 와서 풀면 됩니다. 구간을 종점이 가장 이른 순으로 정렬한 우선순위 큐로 두고, 구간을 하나씩 빼면서 가능한 게 있으면 계속 붙여나가면 됩니다. 
- **$O(N log N)$**에 풀 수 있습니다.
### 서브태스크 2: 무지성 지수풀이
- $N \leq 20$입니다. 누가 봐도 $O(2^N)$이나 $O(N*2^N)$ 정도를 짜면 됩니다.
- 각 구간에 대해, 구간을 선택하거나 선택하지 않을 수 있습니다. 이는 $O(2^N)$입니다.
- 각 2^N가지의 선택에 대해, 선택한 구간들이 겹치지 않는지 확인하면 됩니다. 이는 $O(N)$입니다.
- 따라서, **$O(N 2^N)$**에 풀 수 있습니다.
### 서브태스크 3: 제곱으로 줄이기
- 자, 여기서부터 본격적인 풀이입니다. $N \leq 3000$입니다. $O(N^2)$이나 $O(N^2 log N)$ 정도를 짜면 됩니다.
- 우리가 해야 하는 것이 두 가지인데,
    - 인덱스가 작은 것을 우선으로 하여 구간을 선택
    - 구간을 선택할 때, 겹치지 않음을 보장
    ...입니다.
- 무지성으로 1번 구간부터 하나씩 골라볼 겁니다. 이전에 이미 선택한 구간은 그 선택을 취소하지 않을 것입니다.
- 지금까지 고른 구간과 새로 고를 구간이 겹치지 않는지를 확인해야 합니다. 이를 좀 더 쉽게 하기 위해 좌표 압축을 할 수 있습니다.
- 좌표압축을 통해 수열을 만들어, 구간을 고를 떄마다 그 구간에 해당하는 칸에 1을 더합니다. 이를 누적합으로 구현할 수 있습니다.
- 만약 어떤 구간을 이미 선택했다면, 그 구간에 해당하는 수열의 칸에 1이 더해져 있습니다. 그렇지 않은 구간만 선택해가면서 구간을 고르면 구간을 최대로 고를 수 있습니다.
- 이렇게 하면 **$O(N^2)$**에 풀 수 있습니다.
### 정해 아이디어 1: 차이만 고려하기
- 가 무슨 소리일까요?
- 여러 문제에서, 전체를 계속 업데이트하는 것 대신 매 쿼리나 작업마다 그에 따라 생성되는 차이만을 업데이트하여 시간을 줄일 수 있습니다.
- 서브태스크 3에서 보았던, '우리가 해야 하는 두 가지'를 잘 생각해봅시다.
- 그래서 무지성으로 어떤 구간을 선택해서 이를 사용하기로 했다고 칩시다. 원래는 여기서 다음의 사실을 주목했습니다: (이미 선택한 구간의 수) + (그 외로 겹치지 않게 고를 수 있는 구간의 수) $\leq K$.
- 이 구간 바로 전 구간의 종점 $a$, 바로 다음 구간의 시점 $d$, 선택한 구간의 시종점 $b$, $c$에 대해, 이제 다음에 주목해 봅시다: (이미 선택한 구간의 수) - (선택한 것중 a 이상 d 이하에 있는 것의 수) + (a와 b 사이에서 고를 수 있는 최대 구간의 수) + (c와 d 사이에서 고를 수 있는 최대 구간의 수) + 1 $\leq K$.
- 즉 다음 또한 성립합니다: (이미 선택한 구간의 수) - (a와 d 사이에서 고를 수 있는 최대 구간의 수) + (a와 b 사이에서 고를 수 있는 최대 구간의 수) + (c와 d 사이에서 고를 수 있는 최대 구간의 수) + 1 $\leq K$.
- 어떤 구간 $(l,r)$이 주어질 때, 그 사이에서 겹치지 않는 최대 구간을 최대한 빠르게 구할 수 있는 방법이 있을까요?
### 정해 아이디어 2: 트리는 좋은 거라고 했어요
- 구간들 사이에 위계가 존재하는데(이 경우에는 앞의 구간과 뒤의 구간이 존재합니다), 이를 이용해 임의의 구간에 대해 그 구간에서 시작하는 유향 간선을 그립니다. 간선의 종점은, 그 구간과 겹치지 않게 오른쪽에 있는 정점 중 가장 왼쪽에 있는 정점으로 합시다.
- 루트를 향하는 트리 - 혹은 포레스트 - 가 만들어집니다!
- 이때 '어떤 구간 내에 있는 겹치지 않는 구간의 개수의 최대화'는 이 트리에서 가장 긴 경로를 구하는 것과 같습니다. 더 자세히는, 주어지는 구간이 $(l,r)$이라고 할 때
    - $l \leq L_i$인 $i$ 중 $R_i$가 가장 작은 것을 찾고 $R_j \leq r$ 인 동안 계속 나무의 루트로 이동하면 됩니다.
- 좌표 압축을 통해서, 구간상의 어떤 위치에 대해 그 위치보다 왼쪽에 있는 구간 중 종점 갚이가 가장 얕은(루트에 가까운) 것을 저장합니다.
- 가장 오른쪽의 위치에서부터 시작하여 왼쪽 방향으로 스위핑하듯이 훑으면서 모든 구간의 시작점에 대해 업데이트하면 $O(N log N)$에 전처리할 수 있습니다.
- 스파스 테이블을 이용해, 트리에서 2^k째 조상을 저장하면 트리를 $O(log N)$만에 오를 수 있습니다.
- 따라서 겹치지 않는 최대 구간을 $O(log N)$만에 구할 수 있고, 전처리 $O(N log N)$과 각 구간에 대한 판단 $O(N log N)$을 합치면 **$O(N log N)$**에 풀 수 있습니다.