# Airline Route Map(joisc 2018)
# 문제
앨리스는 JOI 왕국에 살고 있습니다. 그녀는 IOI공화국에 살고 있는 밥을 초대할 것입니다.   
그녀는 그를 초대하기 전에 JOI 왕국의 항공 노선도를 그에게 보낼 계획입니다.   
JOI 왕국은 0부터 $N-1$까지 N개의 섬으로 이루어진 섬나라입니다.   
JOI 왕국에는 M개의 항공 노선이 있습니다. 각 i(0 ≤ i ≤ M−1)에 대해 (i + 1)번째 항공 노선은 $A_i$
섬과 $B_i$ 섬을 양방향으로 연결합니다. 동일한 두 섬을 연결하는 두 항공노선은 없습니다.   
그녀는 JOI 왕국이 운영하는 특수 전신기를 사용해야 합니다. 그녀는 전신기를 사용하여 방향이
없는 그래프를 보낼 수 있습니다. 그러나 이를 사용하면 각 섬과 항공노선의 번호는 무작위로
섞이게 됩니다.   
   
정확하게는 아래와 같이 정보가 전송됩니다. G를 앨리스가 보낸 그래프라고 합시다.    
(V를 G의 정점 수, U를 G의 간선 수라고 가정합니다.)   
   
앨리스는 G의 정점 수 V와 G의 간선 수 U를 지정합니다. 그런 다음 각 숫자 0, 1,
. . . , V − 1 을 각 정점에, 숫자는 각각 0, 1, . . . , U − 1 각 간선에 부여합니다.   
Alice는 매개변수 $C_0, C_1, . . . , C_{U−1}$ 및 $D_0, D_1, . . . , D_{U-1}$를 결정합니다.    
이러한 매개변수는
G의 간선을 나타냅니다. 즉, 각 $j(0 ≤ j ≤ U − 1)$에 대해 G의 j번째 간선은 정점 {C_j}와 정점
{D_j}를 연결합니다.    
G의 정점들의 번호는 JOI Kingdom에 의해 섞입니다. 먼저 JOI Kingdom은 0,1,...V-1의 순열인 
p[0], p[1], . . . , p[V − 1],을 생성합니다. 이후 $C_0, C_1, . . . ,C_{U−1}$은 $p[C_0], p[C1],
. . . , p[C_{U-1}]$ 로 대체되며, $D_0, D_1, . . . , D_{U−1}$은 $p[D_0], p[D_1], . . . , 
p[D_{U-1}]$로 대체됩니다.   
그런 다음 JOI Kingdom에서 G의 간선들의 번호를 섞습니다. 먼저 JOI Kingdom은 0,1,...,U-1의 순열인
q[0], q[1], . . . , q[U − 1]을 생성합니다. 이후 
$C_0, C_1, . . . ,C_{U−1}$은 $C_{q[0]},C_{q[1]}, . . . ,C_{q[U−1]}$로 대체되며, 
$D_0, D_1, . . . , D_{U−1}$은 
$D_{q[0]}, D_{q[1]}, . . . , D_{q[U-1]}$으로 대체됩니다.
다음 데이터가 Bob에게 전송됩니다: V 및 U 값, 매개변수 $C_0, C_1, …C_{U-1}, D_0,D_1,...,D_{U-1}$의
새로운 값   
   
이 전신기를 사용하면 단순 그래프만 보낼 수 있습니다. 여기서 단순 그래프란 다중 간선과 
자가 루프가 없는 그래프를 의미합니다.   
   
즉, 다음 조건을 만족하는 그래프를 보낼 수 있습니다: $(C_i, D_i) , (C_j, D_j)$ 및 $(C_i, D_i) , 
(D_j, C_j)$는
모든 i, j에 대해 만족됩니다$(0 ≤ i < j ≤ U − 1), C_i, D_i$는 모든 $i(0 ≤ i ≤ U − 1)$에 대해
만족됩니다.   
   
Alice는 최대한 적은 정점을 가진 그래프를 사용하여 JOI Kingdom의 항공사 노선도를 Bob에게 보내고
싶어합니다.   
   
Alice와 Bob 사이의 통신을 돕기 위해 다음 두 프로그램을 작성하십시오.   
   
JOI 왕국의 섬 수 N, JOI 왕국의 항공 노선 수 M, JOI 왕국의 항공사 노선도를 나타내는
수열 A, B가 주어지면 첫 번째 프로그램은 앨리스가 보낸 그래프 G의 정보를 출력합니다.   
Bob이 수신한 그래프 G의 정보를 바탕으로 두 번째 프로그램은 JOI Kingdom의 항공 노선 지도를
복구합니다.   
# 구현
두 개의 파일을 제출해야 합니다.   
    
첫 번째 파일은 Alice.cpp입니다. 이 파일은 Alice가 보낸 그래프의 정보를 출력합니다.   
다음 기능을 구현해야 합니다. 프로그램에는 Alicelib.h가 포함되어야 합니다.   
   
void Alice( int N, int M, int A[], int B[] )   
각 테스트케이스에 대해 이 함수는 한 번 호출됩니다.   
매개변수 N은 JOI 왕국의 섬 수입니다.   
매개변수 M은 JOI 왕국의 항공사 노선 수입니다.   
매개변수 A[], B[]는 JOI 왕국의 항공 노선도를 설명하는 길이 M의 수열입니다.   
함수 Alice는 다음 함수를 사용하여 Alice가 보낸 그래프 G의 정보를 출력합니다.   
   
void InitG(int V, int U)   
이 함수는 G의 정점 수와 G의 간선 수를 결정합니다.   
매개변수 V는 G의 정점 수입니다. 매개변수 V는 1에서 1500 사이의 정수여야 합니다. 이 함수에 대한
호출에 이 범위를 벗어난 매개변수가 있는 경우 프로그램은 틀렸습니다[1]으로 간주됩니다.   
매개변수 U는 G의 간선 수입니다. 매개변수 U는 0과 $V(V − 1)/2$ 사이의 정수여야 합니다.   
이 함수에 대한 호출에 이 범위를 벗어나는 매개변수가 있는 경우 프로그램은 틀렸습니다[2]으로
간주됩니다.   
   
void MakeG( int pos, int C, int D )   
이 함수는 G의 간선을 결정합니다.   
매개변수 pos는 호출에 의해 지정된 간선의 번호입니다. 매개변수 pos는 0과 U − 1 사이의
정수여야 합니다. 이 함수에 대한 호출에 이 범위를 벗어난 매개변수가 있는 경우 프로그램은
틀렸습니다[3]으로 간주됩니다. 이 함수는 동일한 매개변수 pos를 사용하여 두 번 이상 호출하면
안 됩니다. 이 함수가 동일한 매개변수로 두 번 이상 호출되면 프로그램은 틀렸습니다[4]으로 간주됩니다.   
매개변수 C와 D는 그래프 G의 간선에 포함된 두 정점입니다. C와 D는 0과 V − 1 사이의 
정수여야 합니다. 또한 C ≠ D를 만족해야 합니다. C나 D가 이러한 조건을 만족하지 않으면
귀하의 프로그램은 틀렸습니다[5]으로 간주됩니다.   
여기서 U와 V는 InitG에서 지정한 정수이다.   
    
Alice 함수에서는 InitG 함수를 한 번 호출한 후 MakeG 함수를 정확히 U번 호출해야 합니다.    
InitG 함수가 두 번 호출되면 프로그램은 잘못된 틀렸습니다[6]으로 간주됩니다. InitG 함수가
호출되기 전에 MakeG 함수가 호출되면 프로그램은 틀렸습니다[7]으로 간주됩니다. Alice 함수가
종료될 때 InitG가 호출되지 않거나 MakeG 함수가 U번 호출되지 않으면 프로그램은 틀렸습니다[8]으로
간주됩니다. Alice 함수가 종료되었을 때, Alice가 설명한 그래프 G가 단순 그래프가 아닌 경우, 
귀하의 프로그램은 틀렸습니다[9]으로 간주됩니다.   
   
Alice 함수에 대한 호출이 잘못된 답변으로 간주되면 프로그램이 즉시 종료됩니다.   
   
두 번째 파일은 Bob.cpp입니다. 이 파일은 Bob이 수신한 그래프 G의 정보를 바탕으로 JOI Kingdom의
항공 노선도를 출력합니다. 다음 기능을 구현해야 합니다. 프로그램에는 Boblib.h가 포함되어야 합니다.   
   
void Bob( int V, int U, int C[], int D[] )   
각 테스트 사례에 대해 이 함수는 한 번 호출됩니다.   
매개변수 V는 그래프 G의 정점 수입니다.   
매개변수 U는 그래프 G의 간선 수입니다.   
매개변수 C[], D[]는 그래프 G의 간선을 나타내는 길이 U의 수열입니다.   
Bob 함수는 다음 함수를 이용하여 JOI Kingdom의 항공사 노선도를 복구하고, 항공사 노선도
정보를 출력해야 합니다.   
   
void InitMap(int N, int M)
이 함수는 JOI 왕국의 섬 수와 JOI 왕국의 항공 노선 수를 지정합니다.   
매개변수 N은 JOI 왕국에서 복구된 섬의 개수입니다. N은 JOI 왕국의 실제 섬 수와 동일한 정수여야 합니다.
동일하지 않으면 프로그램은 틀렸습니다[10]으로 간주됩니다.   
매개변수 M은 JOI 왕국에서 복구된 항공노선 수이다. M은 JOI 왕국의 실제 항공노선의 수와 동일한
정수여야 합니다. 동일하지 않으면 프로그램은 틀렸습니다[11]으로 간주됩니다.  

void MakeMap(int A, int B)   
이 함수는 JOI 왕국의 항공사 노선 수를 지정합니다.   
매개변수 A와 B는 섬 A와 섬 B를 연결하는 항공 노선이 있음을 의미합니다. A와 B는 0과 N − 1 사이
의 정수입니다. 또한 A ≠ B를 만족해야 합니다. A 또는 B가 이러한 조건을 만족하지 않으면 
귀하의 프로그램은 틀렸습니다[12]으로 간주됩니다. JOI Kingdom에 A섬과 B섬을 연결하는 항공노선이
없다면 귀하의 프로그램은 틀렸습니다[13]으로 간주됩니다. 이 함수 호출로 설명되는 항공 경로는
이전 호출의 항공 경로와 달라야 합니다. MakeMap( A, B )가 호출될 때 MakeMap( A, B ) 또는 
MakeMap( B, A )가 이미 호출된 경우 프로그램은 틀렸습니다[14]으로 간주됩니다.   
여기서 N은 InitMap이 지정한 정수값입니다.   
   
Bob 함수에서는 InitMap 함수를 한 번 호출한 후 MakeMap 함수를 정확히 M번 호출해야 합니다. 
InitMap 함수가 두 번 호출되면 프로그램은 틀렸습니다[15]으로 간주됩니다. InitMap 함수가 
호출되기 전에 MakeMap 함수가 호출되면 프로그램은 틀렸습니다[16]으로 간주됩니다.    
Bob 함수가 종료될 때 InitMap이 호출되지 않거나 MakeMap 함수가 M번 호출되지 않으면
프로그램은 틀렸습니다[17]으로 간주됩니다. 여기서 M은 InitMap에서 지정한 정수 값입니다.   
   
Bob 함수에 대한 호출이 잘못된 응답으로 간주되면 프로그램이 즉시 종료됩니다.   
   
# 입력
샘플 그레이더는 표준 입력에서 다음 데이터를 읽습니다.   
   
첫 번째 줄에는 공백으로 구분된 두 개의 정수가 포함되어 있습니다. 이는 JOI 왕국이 N개의 섬으로 
구성되어 있고 JOI 왕국에 M개의 항공 노선이 있음을 의미합니다.   
다음 M개의 줄에는 항공사 노선에 대한 정보가 포함되어 있습니다. (i + 1)번째 
줄(0 ≤ i ≤ M − 1)에는 공백으로 구분된 두 개의 정수 $A_i, B_i$가 포함되는데, 이는 i번 항공노선이
잇는 두 섬의 번호를 나타냅니다.     
# 출력
프로그램이 성공적으로 종료되면 샘플 그레이더는 다음 정보를 표준 출력에 씁니다. 
(실제 따옴표는 쓰지 않습니다.)   
   
+ 프로그램이 오답으로 간주되면 샘플 그레이더는 해당 유형을 “틀렸습니다[1]” 형식으로 작성하고 
종료합니다.   
+ Alice와 Bob에 대한 호출 중 하나라도 잘못된 답변으로 간주되지 않으면 샘플 그레이더는 
"Accepted"라고 씁니다. 또한 V의 값을 출력합니다.   
+ 귀하의 프로그램이 여러 유형의 오답으로 간주되는 경우 샘플 그레이더는 그 중 하나만 보고합니다.
# 제한
$1 ≤ N ≤ 1 000$.   
$0 ≤ M ≤ N(N − 1)/2$.   
$0 ≤ A_i ≤ N − 1 (0 ≤ i ≤ M − 1)$.   
$0 ≤ B_i ≤ N − 1 (0 ≤ i ≤ M − 1)$.   
$A_i ≠ B_i (0 ≤ i ≤ M − 1)$.   
$(A_i, B_i) ≠ (A_j, B_j) and (A_i, B_i) ≠ (B_j, A_j) (0 ≤ i < j ≤ M − 1)$.   
# 점수
서브태스크 1 또는 서브태스크 2에서 프로그램이 모든 테스트케이스를 해결하면 만점을 얻습니다.   
서브태스크 3에서 프로그램이 모든 테스트케이스를 해결하면 점수는 다음과 같이 계산됩니다. MaxDiff를
V − N의 최대값으로 설정합니다.   
101 ≤ MaxDiff일 때 점수는 0입니다.   
21 ≤ MaxDiff ≤ 100일 때 점수는 $13 + [(100 − MaxDiff)/4]$입니다. 여기서 [x]는 x를 초과하지 않는
가장 큰 정수입니다.   
13 ≤ MaxDiff ≤ 20일 때 점수는 $33 + (20 − MaxDiff) × 3$입니다.   
MaxDiff가 12 이하이면 점수는 63입니다.   
## 예제
다음은 샘플 그레이더에 대한 샘플 입력과 그에 대응되는 함수의 호출입니다.   
<table>
  <tr>
    <td rowspan="2">예시 입력1</td>
    <td colspan="4">예시 호출</td>
  </tr>
  <tr>
    <td>호출</td>
    <td>반환</td>
    <td>호출</td>
    <td>반환</td>
  </tr>
  <tr>
    <td rowspan="6">5<br/>4<br/>2<br/>5<br/>3<br/>1</td>
    <td> Solve(5)</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
  <td></td>
  <td>Query( { 1,1,1,0,0 } )</td>
  <td></td>
  </tr>
  <tr>
    <td></td>
  <td></td>
  <td></td>
  <td>2</td>
  </tr>
  <tr>
    <td></td>
  <td></td>
  <td>Answer( { 4,2,5,3,1 } )</td>
  <td></td>
  </tr>
  <tr>
    <td></td>
  <td></td>
  <td></td>
  <td>(none)</td>
  </tr>
  <tr>
    <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
</table>

이 문제에서, 책들이 오른쪽에서 왼쪽으로 배치되었는지, 혹은 반대인지를 구분할 필요는 없습니다.   
따라서 당신의 프로그램은 매개변수가 뒤집힌 Answer({1,3,5,2,4})를 호출해도 정점으로 간주됩니다.   
# 서브태스크
|번호|배점|제한|
|---|---|---|
|1|19|$N \le 200$|
|2|81|추가 제약조건이 없습니다.|
+ ## Subtask 1. ( $19점$)
굉장히 다양한 풀이가 있을 수 있습니다. 한 가지 생각해볼 수 있는 단순한 방법은, 모든 두 책의 쌍에
대해서 쿼리를 날려보는 것입니다. 그렇게 하면 각 책들의 연결성을 알 수 있고, 따라서 좌우반전을
제외하고는 답을 알아낼 수 있습니다.   
+ ## Subtask 2. ( $100점$)
 서브태스크 1의 방법을 사용하기에는 과도하게 많은 쿼리 횟수가 필요하므로, 조금 더 빠르게 문제를 풀 수 있는 방법을 생각해야 합니다.   
 한 가지 생각해볼 수 있는 방법은 어떤 책과 인접한 다른 책을 빠르게 찾아내는 것입니다.   
우선 한 가지 알아야 하는 사실은 특정한 책들의 번호의 집합 $A$가 있고 그 여집합 $B$가 있다고 할 때, 다음과 같은 사실이 성립한다는 점입니다.
참고로, 1과 n이라 함은 선반을 기준으로 한 번호를 의미합니다. 즉, 양 끝 책들을 의미합니다.   
+ 만약 1 혹은 n이 $A$에 포함된다면, Query(A)>=Query(B)이며, 역도 성립한다.<br/>

즉, 아직까지 탐색되지 않은 책들의 끝부분들을 차례차례 찾아나가는 방식으로 풀이를 할 생각을 할 수 있습니다. 이러한 방식이 성립하는 이유는,
선반의 가장 끝부분에 있는 책을 찾아낸 뒤 그 책을 제거하고 나면 크기가 하나 작아진 똑같은 문제를 해결해서 아직까지 규명된 적 없는,
선반 내에서 연속한 책들에 대해 동일한 문제를 다시 풀 수 있고, 그곳에서 발견한 끝부분이 지금까지 탐색된 책들을 기준으로 어디에 있는지는 단순히
한 번의 쿼리를 통해 연결성을 판별하면 되기 때문입니다.<br/>
따라서, 목표는 초기 상태에서 선반의 끝부분에 있는 책을 충분히 빠르게(대략 $O(log n)$에) 해결하는 것입니다. 이는 어떻게 할 수 있을까요?   <br/>
잘 생각해보면, 이는 이분탐색을 통해 처리할 수 있음을 알 수 있습니다. 위에서 발견했던 성질을 여기에서 활용하게 되는데, 특정한 책들의 집합 내에
1 혹은 n이 존재하는지에 대한 판별을 할 수 있기 때문입니다. 그렇다면 대략적으로 탐색을 하는 과정은 다음과 같을 것입니다:   <br/>
  처음에는 탐색되지 않은 모든 책들을 A에 집어넣고, A의 크기의 대략 절반인 아무 부분집합 A'을 잡고, A'에 1 혹은 n이 있는지 판별합니다.   <br/>
  만약 1 혹은 n이 존재한다면, A=A'으로 세팅하고, 그렇지 않다면 A-=A'를 진행합니다.   <br/>
 이러한 방식의 이분탐색을 진행하면 마지막에는 1과 n 둘 중 하나를 얻을 수 있고, 우리의 목표가 달성되었습니다.   <br/>
앞서 말한 방식으로 문제의 크기를 1씩 줄여나가면서 해결해주면 전체 답을 얻을 수 있습니다. 하나의 끝을 발견하는데에 대략 $2 log n + 1$정도의 쿼리가
사용되긴 하지만, 항상 저만큼의 쿼리가 소요되는 것은 아니고 문제의 크기가 줄어듦에 따라 소모가 점진적으로 나아지기 때문에 쿼리 제한을 초과하는 문제에 직면하진 않습니다.
