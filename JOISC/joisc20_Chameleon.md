# Chameleon's love(joisc 2020)
# 문제
JOI 동물원에는 1에서 $2N$까지 번호가 매겨진 2N개의 카멜레온이 있습니다. 그 중 N개의 카멜레온은 성별이 X이고 나머지 N개의 카멜레온은 성별이 Y입니다.   

각 카멜레온은 고유한 색상을 가지고 있습니다. 다음은 원래 색상에 대해 알려져 있습니다.   

X성 N카멜레온의 본래 색깔은 뚜렷합니다.   
성별 X의 각 카멜레온에는 동일한 원래 색상을 가진 고유한 성별 Y의 카멜레온이 존재합니다.   
지금 JOI동물원은 새로운 사랑의 계절입니다.   

각 카멜레온은 다른 카멜레온을 사랑합니다. 다음은 카멜레온의 사랑에 대해 알려져 있습니다.
+ 각 카멜레온은 성별이 다른 정확히 한 카멜레온을 사랑합니다.
+ 카멜레온과 자신이 사랑하는 카멜레온은 본래의 색이 다릅니다.
+ 같은 카멜레온을 사랑하는 두 마리의 카멜레온은 존재하지 않습니다.   
카멜레온을 모아 회의를 조직할 수 있습니다. 회의에 참석한 각 카멜레온이 사랑하는 카멜레온이 되자. s의 피부색은 다음과 같이 결정됩니다.

+ t가 회의에 참석하면 s의 피부색은 t의 원래 색상입니다.   
+ t가 회의에 참석하지 않으면 s의 피부색은 s의 원래 색상입니다.   
카멜레온의 피부색은 모임에 따라 바뀔 수 있습니다. 당신이 조직하는 각 회의마다 회의에 참석하는 카멜레온의 피부색 종류의 수를 셀 수 있습니다.   
   
최대 20,000번의 회의를 구성하여 동일한 원래 색상을 가진 모든 카멜레온 쌍을 결정하려고 합니다.   
   
카멜레온의 수가 주어졌을 때 최대 20,000번 회의를 조직하여 동일한 원래 색상을 가진 모든 카멜레온 쌍을 결정하는 프로그램을 작성하십시오.   
# 구현   
하나의 파일을 제출해야 합니다.   
   
제출하는 파일의 이름은 chameleon.cpp입니다. 다음 기능을 구현해야 합니다. 프로그램은 chameleon.h를 포함해야 합니다.   
   
+ void Solve(int N)
+ 이 함수는 각 테스트 케이스에 대해 정확히 한 번만 호출됩니다.
+ 파라미터 N은 성별이 X인 카멜레온의 수인 N입니다.
+ 프로그램은 다음 함수를 호출할 수 있습니다.
   
+ int Query(const std::vector &p)
+ 이 함수를 호출하여 카멜레온 회의를 구성합니다.
+ 파라미터 p는 회의에 참석한 카멜레온의 목록입니다.
+ 반환 값은 회의에 참석한 카멜레온의 피부색 종류의 수입니다.
+ 파라미터 p의 각 요소는 1과 2N 사이의 정수여야 합니다. 이 조건이 만족되지 않으면 프로그램이 오답[1]으로 판정됩니다.
+ 파라미터 p의 요소는 구별되어야 합니다. 이 조건이 만족되지 않으면 프로그램이 오답[2]으로 판정됩니다.   
   
프로그램은 Query 함수를 20,000회 이상 호출하면 안 됩니다. 이 조건이 만족되지 않으면 프로그램이 오답[3]으로 판정됩니다.
+ void Answer(int a, int b)
+ 이 함수를 호출하면 원래 색상이 동일한 한 쌍의 카멜레온에 응답합니다.
+ 파라미터 a와 b는 카멜레온 a와 카멜레온 b가 원래 색상이 같다는 것을 의미합니다.
+ $1 ≤ a ≤ 2N$ 및 $1 ≤ b ≤ 2N$이어야 합니다. 이러한 조건이 충족되지 않으면 프로그램이 오답[4]로 판정됩니다.
   
프로그램은 a 또는 b의 동일한 값을 총 두 번 이상 사용하여 이 함수를 호출해서는 안 됩니다. 이 조건이 만족되지 않으면 프로그램이 오답[5]로 판정됩니다.   
카멜레온 a와 카멜레온 b의 원래 색상이 다른 경우 프로그램은 오답[6]으로 판단됩니다.   
프로그램은 Answer 함수를 정확히 N번 호출해야 합니다. 함수 Solve가 종료될 때 Answer 함수에 대한 호출 횟수가 N이 아닌 경우 프로그램은 오답[7]으로 판단됩니다.
# 제한   
$2 ≤ N ≤ 500$.   
$0 ≤ Y_i ≤ 1(1 ≤ i ≤ 2N)$.   
$1 ≤ C_i ≤ N(1 ≤ i ≤ 2N)$.   
각 $j(1 ≤ j ≤ N)$에 대해 $Y_i = 0$ 및 $C_i = j$를 만족하는 고유한 $i(1 ≤ i ≤ 2N)$가 존재합니다.   
각 $j(1 ≤ j ≤ N)$에 대해 $Y_i = 1$ 및 $C_i = j$를 만족하는 고유한 $i(1 ≤ i ≤ 2N)$가 존재합니다.   
$1 ≤ L_i ≤ 2N(1 ≤ i ≤ 2N)$.   
$Y_i ≠ Y_{L_i} (1 ≤ i ≤ 2N)$.   
$C_i ≠ C_{L_i}(1 ≤ i ≤ 2N)$.   
$L_k ≠ L_l(1 ≤ k < l ≤ 2N)$.   
$Y_i(1≤i≤2N)$는 카멜레온 i의 성별로 0 또는 1이다. X이면 0, Y이면 1이다.   
   
$C_i(1≤i≤2N)$는 카멜레온 i의 원래 색으로 1보다 크거나 같고 N보다 작거나 같은 정수이다.   
   
$L_i(1 ≤ i ≤ 2N)$는 카멜레온 i가 사랑하는 카멜레온의 숫자입니다.
# 서브태스크
|번호|배점|제한|
|---|---|---|
|1|4|$L_{L_i} = i (1 ≤ i ≤ 2N)$|
|2|20|$N ≤ 7$|
|3|20|$N ≤ 50$|
|4|20|$Y_i = 0 (1 ≤ i ≤ N)$|
|5|36|추가 제약조건이 없음|
+ ## Subtask 1. ( $4점$)
우선, 모든 풀이에 공통적으로 "무향 간선"과 "유향 간선"을 정의하겠습니다. 만약 두 카멜레온이 동일한 색상을 가지고 있는 경우, 그 둘 사이에 "무향 간선"이 존재하고, 어떤 카멜레온이 다른 카멜레온을 사랑하지만 반대는 성립하지 않을 때, 사랑하는 카멜레온으로부터 "유향 간선"이 존재합니다. 이러한 정의 하에서, 어떤 사이에 간선이 있는 두 카멜레온을 집어넣으면 1이 반환되어, 그 사이 간선의 존재유무를 알 수 있습니다. 우선 본 서브태스크의 조건은 유향간선이 존재하지 않는다는 것과 동일합니다.
+ 이 경우 관찰할 수 있는 사실은, 모든 카멜레온 사이에 색깔의 교환이 상호적으로 발생하기 때문에 색깔 변화를 무시해도 상관없다는 것입니다. 따라서, 어떤 카멜레온과 다른 카멜레온들의 집합에 대해, 그 카멜레온과 동일한 색상의 집합이 존재하는지를 쉽게 확인 가능하며, 이를 통해 이분탐색을 진행하면 모든 색이 같은 카멜레온의 쌍을 확인 가능합니다.
+ ## Subtask 2,3. ( 도합 $40점$)
서브태스크 2는 N이 매우 작은 브루트포스이므로, 3과 함께 서술하겠습니다.
+ 각 카멜레온들의 쌍마다 쿼리를 묻습니다. 이렇게 하면 두 카멜레온 사이에 어떤 간선이 존재하는지의 여부를 알 수 있습니다. 이러한 방식을 통해 어떤 카멜레온 A 사이에 변이 존재하는 카멜레온들을 찾아낼 수 있는데, 그 카멜레온들의 마릿수는 3마리이거나, 한마리입니다.
+ 만약 어떤 카멜레온과 변이 존재하는 마릿수가 1이라면, 이는 그 카멜레온과 연결된 유향간선이 존재하지 않는다는 것과 동일하기 때문에, 그 카멜레온과 동일한 색을 특정지을 수 있습니다.
+ 만약 그 마릿수가 3이라면, 다음과 같은 가짓수가 존재합니다:
+ ![그림1](https://github.com/ibm2006/ibm2006/assets/130548041/d9ae1bae-d0f6-4447-a269-3e116e86baa5)
+ 즉, 자신이 향하는 유향 간선으로 연결된 카멜레온이 무엇인지 특정지을 수 있습니다. 이를 통해, 유향간선으로 연결됨이 확정된 카멜레온에 대해서 논의를 진행해보면, 해당 카멜레온은 자신에게서 나오는 유향 간선으로 연결된 카멜레온을 알며, 자신을 향하는 유향 간선으로 연결된 카멜레온을 알기 때문에 나머지 하나의 카멜레온이 색이 동일한 카멜레온임을 알 수 있습니다.
+ 이러한 방식을 통해 모든 카멜레온의 쌍을 알아낼 수 있습니다.
+ ## Subtask 4. ( $20점$)
카멜레온의 성을 알 수 있으므로, 이분탐색을 통해 간선이 존재하는 카멜레온들을 빠르게 추출할 수 있습니다(어떠한 경우에도 같은 성끼리는 간선이 존재하지 않기 때문).
+ ## Subtask 5. ( $36점$)
카멜레온의 성을 알 수 없기 때문에, 이분탐색을 적용하기가 쉽지 않습니다. 다만, 어떤 카멜레온의 성을 X라고 해도 아무런 문제가 없기 때문에, 초기 상태에서 이러한 방식으로 세팅을 진행하겠습니다.
+ 이제, 다른 카멜레온들을 한 마리씩 가져오면서 이분탐색을 진행할 것입니다. 어떤 상태에서, 각 카멜레온들은 서로 성이 반대이거나 같은지 판별 가능할 수도 있고, 혹은 정보가 불충분해서 성을 판별 불가능할 수도 있습니다. 이러한 구조를 이분그래프를 통해 적절히 관리하며, 서로 연결되지 않은 컴포넌트는 아무렇게나 두어 다른 컴포넌트와의 성을 임의로 정해둡니다.
+ 이렇게 결정된 각 성들에 대해, 이분탐색을 돌리면서 간선이 존재하는 카멜레온을 찾을 수 있습니다. 만약 어떤 다른 컴포넌트의, 임시로는 동일하게 두었던 성에 존재하는 카멜레온들의 성이 실제로 다른 경우를 걱정할 수 있겠지만, 그러한 경우에는 그 전 두 컴포넌트의 어떤 카멜레온을 넣었을 때 그 사이에 변이 존재하지 않는 것으로 판정되었기 때문에 그 둘 사이에 간선이 존재하지 않고, 유일하게 간선이 발생 가능한 경우는 이번에 새로 추가한 카멜레온에 의한 것뿐이라는 사실을 알 수 있습니다.
+ 이렇게 새로운 카멜레온과 연결된 간선을 알고 나면, 각 컴포넌트와 새 카멜레온 사이의 상대적인 성을 알 수 있고, 이를 통해 컴포넌트들을 통합해줄 수 있습니다. 물론 연결된 간선이 없었다고 해도, 새 카멜레온 하나로 컴포넌트를 구성하면 됩니다.
+ 이러한 방식을 통해, 각 카멜레온들마다 이분탐색을 통해 성들을 결정해나가며 사이에 변이 존재하는 카멜레온들을 규명해내면 문제가 해결됩니다.
+ 생각보다 쿼리의 수가 많지 않기 때문에, 비효율적으로 짜면 실패합니다.
