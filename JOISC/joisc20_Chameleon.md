# Chameleon's love(joisc 2020)
# 문제
JOI 동물원에는 1에서 $2N$까지 번호가 매겨진 2N개의 카멜레온이 있습니다. 그 중 N개의 카멜레온은 성별이 X이고 나머지 N개의 카멜레온은 성별이 Y이다.

각 카멜레온은 고유한 색상을 가지고 있습니다. 다음은 원래 색상에 대해 알려져 있습니다.

X성 N카멜레온의 본래 색깔은 뚜렷하다.
성별 X의 각 카멜레온에는 동일한 원래 색상을 가진 고유한 성별 Y의 카멜레온이 존재합니다.
지금 조이동물원은 새로운 사랑의 계절입니다.

각 카멜레온은 다른 카멜레온을 사랑합니다. 다음은 카멜레온의 사랑에 대해 알려져 있습니다. • 각 카멜레온은 성별이 다른 정확히 한 카멜레온을 사랑합니다.
카멜레온과 자신이 사랑하는 카멜레온은 본래의 색이 다릅니다.
같은 카멜레온을 사랑하는 두 마리의 카멜레온은 존재하지 않습니다.
카멜레온을 모아 회의를 조직할 수 있습니다. 회의에 참석한 각 카멜레온이 사랑하는 카멜레온이 되자. s의 피부색은 다음과 같이 결정됩니다.

t가 회의에 참석하면 s의 피부색은 t의 원래 색상입니다.
t가 회의에 참석하지 않으면 s의 피부색은 s의 원래 색상입니다.
카멜레온의 피부색은 모임에 따라 바뀔 수 있습니다. 당신이 조직하는 각 회의마다 회의에 참석하는 카멜레온의 피부색 종류의 수를 셀 수 있습니다.

최대 20,000번의 회의를 구성하여 동일한 원래 색상을 가진 모든 카멜레온 쌍을 결정하려고 합니다.

카멜레온의 수가 주어졌을 때 최대 20,000번 회의를 조직하여 동일한 원래 색상을 가진 모든 카멜레온 쌍을 결정하는 프로그램을 작성하십시오.
# 구현
총 2개의 파일을 구현해야 합니다.   
<br/> 첫 번째 파일은 Anna.cpp입니다. Anna의 전략을 구현해야 합니다. 다음 기능을 구현해야 합니다. 프로그램은 전처리 지시문 #include를 사용하여 Anna.h를 포함해야 합니다.   
<br/>
+ void Anna(int N, int K, std::vector<int> R, std::vector<int> C)   
+ 이 함수는 깃발에 정수를 쓰는 Anna의 전략을 구현합니다. 각 시나리오(스코어링 참조)에 대해 이 함수는 처음에 정확히 한 번 호출됩니다.   
+ 파라미터 N은 JOI 왕국의 땅이 N 행과 N 열로 구성된 정사각형 격자의 그리드임을 의미합니다.   
+ 파라미터 K는 파티의 후보 격자의 개수 $K(=7)$입니다.   
+ 파라미터 R과 C는 길이 K의 배열입니다. 여기서 R[i]와 C[i] $(0 ≤ i ≤ K − 1)$는 후보 셀 i의 셀 $(Ri, Ci)$을 나타냅니다.   
+ 파라미터 N, K, R[i] 및 C[i] $(0 ≤ i ≤ K − 1)$ 값의 범위는 제약 조건을 참조하십시오.   
+ Anna에 대한 각 함수 호출에 대해 다음 함수는 정확히 $N^2$번 호출되어야 합니다. 모든 격자에 대해 한 번씩 호출해야 합니다.   
<br/> void SetFlag(int r, int c, int value)
+ 파라미터 r 및 c는 Anna가 격자 $(r, c)$의 깃발에 정수를 쓴다는 것을 의미합니다. 여기서 $0 ≤ r ≤ N-1, 0 ≤ c ≤ N-1$을 만족해야 한다. 이 조건이 만족되지 않으면 프로그램이 오답[1]으로 판정됩니다.
+ 파라미터 value는 Anna가 깃발에 쓰는 정수입니다. 여기서 $1 ≤ value ≤ 1 000 000 000$을 만족해야 합니다. 이 조건이 만족되지 않으면 프로그램이 오답[2]으로 판정됩니다.
함수 SetFlag가 동일한 매개변수 $(r, c)$로 두 번 이상 호출되면 프로그램이 오답으로 판단됩니다[3].
Anna 함수가 종료될 때 SetFlag 함수에 대한 함수 호출 횟수가 $N^2$와 다르면 프로그램이 오답[4]으로 판단됩니다.   
SetFlag 함수에 대한 함수 호출이 오답으로 간주되면 프로그램이 즉시 종료됩니다.
+ 두 번째 파일은 Bruno.cpp입니다. 브루노의 전략을 구현해야 합니다. 다음 기능을 구현해야 합니다. 프로그램은 전처리 지시문 #include를 사용하여 Bruno.h를 포함해야 합니다.   
<br/> std::vector<int> Bruno(int K, std::vector<int> value) 
+ 이 함수는 Bruno의 다음 작업을 설명해야 합니다. 각 시나리오(스코어링 참조)에 대해 Anna 함수가 호출된 후 이 함수가 정확히 한 번 호출됩니다.
+ 파라미터 K는 파티의 후보 격자의 개수 $K(=7)$입니다.
+ 파라미터 value는 길이 9의 배열입니다. Bruno의 현재 격자와 주변 8개 격자의 깃발에 쓰여진 정수를 포함합니다. 보다 정확하게는 Bruno가 현재 깃발 $(a, b)$에 있는 경우 $(1 ≤ a ≤ N − 2, 1 ≤ b ≤ N − 2)$ value[0], value[1], . . . , value[8]은 $(a−1, b−1), (a−1, b), (a−1, b+1), (a, b−1), (a, b), (a, b+1), (a+1, b−1), (a+1, b), (a+1, b+1)$ 격자의 깃발에 쓰여진 정수입니다
+ 모든 $t = 0, 1, 2, . . . , K − 1$에 대해, 함수 Bruno는 파티가 후보 격자 t에서 개최될 때 Bruno의 다음 행동을 결정해야 합니다. 반환 값은 길이 K의 배열입니다. 배열의 $(i + 1)$번째 요소 $(0 ≤ i ≤ K − 1)$는 $t = i$에 대한 Bruno의 다음 동작이어야 합니다.
+ 반환 값이 길이 K의 배열이 아닌 경우 프로그램은 오답[5]으로 판단됩니다.
+ 배열의 모든 요소는 0, 1, 2, 3 또는 4 중 하나여야 합니다. 이 조건이 충족되지 않으면 프로그램이 오답으로 판단됩니다[6].
+ 매 t마다 Bruno 함수가 주는 행동이 Bruno의 다음 행동이 되어야만 최소한의 행동으로 파티 장소로 이동할 수 있습니다. 특히 그의 다음 행동이 행동 4라면 그의 현재 격자는 파티를 위한 장소여야 합니다. 이 조건이 만족되지 않으면 프로그램이 오답으로 판정됩니다[7]. 최소한의 액션으로 파티를 위한 장소로 이동하는 방법이 여러 가지라면 반환 값은 그 중 하나가 될 수 있습니다.   
<br/>
이 작업에서 각 테스트 사례는 Q 시나리오로 구성됩니다. 각 시나리오에서 Anna 함수와 Bruno 함수는 각각 정확히 한 번만 호출됩니다. 따라서 각 테스트 케이스에 대해 Anna 함수와 Bruno 함수를 각각 Q번이라고 합니다. 이러한 함수는 교대로 호출됩니다. 자세한 내용은 채점을 참조하십시오.
