# Ancient Machine(joisc 2021)
# 문제

안나와 브루노는 고고학자입니다. 그들은 IOI 왕국의 폐허를 탐사합니다. 폐허 A에서 Anna는 오래된 기계의 설계도를 발견했습니다. 
폐허 B에서 브루노는 실제 기계를 발견했습니다.

이 기계는 N개의 장치로 구성되어 있습니다. 장치는 일렬로 전선에 부착됩니다. X, Y, Z라는 세 가지 유형의 장치가 있습니다. 
왼쪽부터 0부터 $N − 1$까지 장치 번호가 매겨져 있습니다. 장치 $i(0 ≤ i ≤ N − 1)$의 유형은 $S_i$입니다. 즉, $S_i$는 X, Y 또는 Z입니다.

기계가 너무 크기 때문에 Bruno는 기계에서 장치를 하나씩 제거하기로 결정했습니다. 그러나 장치들은 전선을 통해 서로 상호작용하기 때문에 
제거 순서에 매우 주의해야 한다.

기계에서 장치를 제거하는 방법과 관련하여 다음을 정의합니다.

장치 $x,y,z(0 ≤ x < y < z ≤ N − 1)$ 가 아직 제거되지 않았고 $S_x = X, S_y = Y, S_z = Z$라고 가정합니다. 또한 모든 $x < j < y$인 j에 대해 장치 j가 이미
제거되어있었다고 합시다. 또한, 모든 $y < k < z$에 대해 장치 k가 이미 제거되었다고 합시다. 이러한 조건이 모두 충족될 때 장치 y를 기계에서 제거하면 
이를 좋은 제거라고 합니다.
기계에서 장치를 제거하는 다른 방법은 좋은 제거가 아닙니다.
Bruno는 제거 가능한 횟수가 최대가 되도록 기계에서 N개의 장치를 모두 제거해야 합니다. 그러나 세 가지 유형의 장치는 유사해 보이기 때문에 장치 유형을 구별할 수 없습니다.

Anna는 기계의 설계도를 알고 있으므로 기계에 연결된 각 장치의 유형을 알고 있습니다. 따라서 그녀는 브루노를 돕기 위해 송신기를 사용할 것입니다. 송신기를 사용하여 
일련의 문자를 보낼 수 있습니다. 그녀가 보낼 수 있는 각 문자는 0 또는 1입니다.

Anna의 전략과 Bruno의 전략을 구현하여 좋은 제거 횟수가 최대가 되도록 프로그램을 작성하세요. 안나가 브루노에게 보낸 문자 수가 적을수록 더 높은 점수를 
얻게 됩니다.
# 구현
두 개의 파일을 제출해야 합니다.

첫 번째 파일은 Anna.cpp입니다. Anna의 전략을 구현해야 합니다. 다음 함수를 구현해야 합니다. 프로그램은 전처리 지시문 #include를 사용하여 Anna.h를 포함해야 합니다.

void Anna(int N, std::vector<char> S)
각 테스트케이스에 대해 이 함수는 처음에 정확히 한 번 호출됩니다.
파라미터 N은 장치의 개수 N입니다.
파라미터 S는 길이 N의 배열입니다. 이는 S[i]가 장치 i의 유형 $S_i(0 ≤ i ≤ N − 1)$임을 의미합니다. 여기서 문자 S[i]는 'X', 'Y' 또는 'Z'입니다.
프로그램은 다음 함수를 호출할 수 있습니다.

void Send(int a)
이 함수를 호출하여 Anna는 0 또는 1이라는 문자를 Bruno에게 보냅니다.
파라미터 a는 브루노에게 보내는 정보입니다. 0 또는 1이어야 합니다. 이 조건을 만족하지 않으면 프로그램은 오답[1]으로 판단됩니다.
Send 함수는 200,000회 이상 호출하면 안 됩니다. 200,000회 이상 호출되면 해당 프로그램은 오답[2]으로 판단됩니다.
두 번째 파일은 Bruno.cpp입니다. 브루노의 전략을 실행해야 합니다. 다음 함수를 구현해야 합니다. 프로그램은 전처리 지시문 #include를 사용하여 Bruno.h를 포함해야 합니다.

void Bruno(int N, int L, std::vector<int> A)
Anna 함수가 호출된 후 이 함수는 정확히 한 번 호출됩니다.
파라미터 N은 장치의 개수 N입니다.
파라미터 L은 Anna가 보낸 문자 수 L(0 또는 1)입니다.
파라미터 A는 길이 L의 배열입니다. 이는 Anna가 순서대로 문자 A[0],A[1],...,A[L-1]을 Bruno에게 보냈다는 의미입니다. 배열의 각 문자는 0 또는 1입니다.
프로그램은 다음 함수를 호출할 수 있습니다.

void Remove(int d)
이 함수를 호출하면 프로그램이 장치를 제거하는 방법에 대해 응답합니다.
매개변수 d는 장치의 인덱스입니다. 이는 브루노가 장치를 제거했다는 의미입니다.
부등식 $0 ≤ d ≤ N − 1$이 충족되어야 합니다. 이 조건이 만족되지 않으면 귀하의 프로그램은 오답[3]으로 판단됩니다.
동일한 매개변수 d를 사용하여 이 함수를 두 번 이상 호출하는 것은 허용되지 않습니다. 이 조건이 만족되지 않으면 귀하의 프로그램은 오답[4]으로 판단됩니다.
Remove 함수는 정확히 N 번 호출되어야 합니다. Bruno 함수가 종료되었을 때 Remove 함수 호출 횟수가 N회와 다르면 해당 프로그램은 오답[5]으로 판단됩니다.
N개의 장치를 모두 제거한 후 제대로 제거되는 횟수는 가능한 최대값이어야 합니다. 이 조건이 만족되지 않으면 귀하의 프로그램은 오답[6]으로 판단됩니다. 
   
# 입력
샘플 그레이더는 다음과 같은 형식으로 데이터를 읽습니다.
<table>
  <tr>
    <td>
      $N$   <br/>
      $S_0 S_1 ... S_{N-1}$
    </td>
  </tr>
</table>
   
이때 $S_i, S_{i+1}$은 공백으로 분리되어 있습니다.
# 출력
프로그램이 성공적으로 종료되면 샘플 그레이더는 다음 정보를 표준 출력에 기록합니다.

귀하의 프로그램이 오답[1], [2], [3], [4], [5] 중 하나로 판단되면 해당 유형을 “오답[1]”로 기록합니다.
그렇지 않으면 Send에 대한 함수 호출 수 L과 양호한 제거 수 D를 "Accepted: L D"로 기록합니다. 
샘플 그레이더의 동작은 실제 그레이더와 다릅니다. 샘플 그레이더는 귀하의 프로그램이 
오답[6]으로 판단되는지 여부를 확인하지 않습니다.
귀하의 프로그램이 여러 유형의 오답 [1], [2], [3], [4] 또는 [5]로 판단되는 경우 샘플 그레이더는 그 중 하나만 보고합니다.
# 제한
$3 ≤ N ≤ 100000$.   
$S_i$는 X,Y,Z중 하나입니다($0\le i\le N-1$).   
# 서브태스크 1 (5점)
$N\le 18$
# 서브태스크 2 (95점)
추가 제한사항이 없습니다. 이 서브태스크에서, 귀하의 점수는 다음 방식으로 계산됩니다.
+ L을 이 서브태스크에 속한 모든 테스트케으스들에 대해서 Send 함수를 실행한 횟수의 최댓값이라 합니다.
+ 귀하의 점수는 다음과 같이 계산됩니다.
+ $160000\lt L \le 200000$일 경우, 귀하의 점수는 $25+\left\lfloor 10\times ((200000-L)/40000) \right\rfloor$점입니다.
+ $100000\lt L \le 160000$일 경우, 귀하의 점수는 $35+\left\lfloor 30\times ((160000-L)/60000) \right\rfloor$점입니다.
+ $70000\lt L \le 100000$일 경우, 귀하의 점수는 $65+\left\lfloor 30\times ((100000-L)/30000)^2 \right\rfloor$점입니다.
+ $L \le 70000$일 경우, 귀하의 점수는 $95$점입니다.

이때, $\left\lfloor x \right\rfloor$는 x를 넘지 않는 가장 큰 정수입니다.
## 예제
다음은 샘플 그레이더에 대한 샘플 입력과 그에 대응되는 함수의 호출입니다.   
<table>
  <tr>
    <td rowspan="2">예시 입력1</td>
    <td colspan="2">예시 호출</td>
  </tr>
  <tr>
    <td>호출</td>
    <td>호출</td>
  </tr>
  <tr>
    <td rowspan="20">4 3<br/>0 1<br/>0 2<br/>0 3<br/></td>
    <td> Anna(4,{X,Y,X,Z})</td>
    <td></td>
  </tr>
  <tr>
    <td></td>
  <td>Send(0)</td>
  </tr>
  <tr>
    <td></td>
  <td>Send(1)</td>
  </tr>
   <tr>
    <td>Bruno(4,2,{0,1})</td>
  <td></td>
  </tr>
   <tr>
    <td></td>
  <td>Remove(2)</td>
  </tr>
   <tr>
    <td></td>
  <td>Remove(1)</td>
  </tr>
   <tr>
    <td></td>
  <td>Remove(0)</td>
  </tr>
   <tr>
    <td></td>
  <td>Remove(3)</td>
  </tr>
</table>

이러한 샘플 함수 호출에서는 4개의 장치가 다음 방법으로 제거됩니다.

1. 처음에는 4개의 장치가 X Y X Z입니다.
2. Bruno는 2번째 장치를 제거합니다. 전체 장치는 X Y - Z가 됩니다. 여기서 -는 이 위치에 있는 장치가 이미 제거되었음을 의미합니다.
3. Bruno는 1번째 장치를 제거합니다. 전체 장치는 X - - Z가 됩니다. (x, y,z) = (0, 1, 3)이 조건을 만족하므로 좋은 제거입니다.
4. Bruno는 0번째 장치를 제거합니다. 전체 장치는 - - - Z가 됩니다.
5. 마지막으로 브루노는 3번째 장치를 제거합니다. 전체 장치는 - - - -가 됩니다. 좋은 제거 횟수는 1입니다.
이러한 예제 입력에서 좋은 제거 수는 1보다 클 수 없습니다.
+ ## Subtask 1. ( $5점$)
우선, Anna의 경우에는 단순히 자신이 가지고 있는 문자열의 정보를 넘겨주기만 하면 되므로, Bruno에게 정보를 전달하는 데에서는 아무런 문제가 없습니다. 이제 장치를 제거할 수 있는 가능한 모든 방법들을 체크해주거나, 혹은 비트dp로 적절히 계산해주면 나이브하게 최대 좋은 제거 횟수와 그 방법을 알 수 있습니다.
+ ## Subtask 2. ( $L=200000, 30$점)
 총 세 종류의 문자가 있으므로, 2비트를 사용하면 한 위치에 있는 문자의 종류를 알려줄 수 있습니다. 따라서 문제를 풀 전략만 생각하면 됩니다.

 좋은 제거를 최대화하는 방법은 무엇일까요? 일단 맨 처음 등장하는 X는 분명히 가장 마지막에 지우는게 이득일 것이라 추측 가능하며, 그에 따라 그 앞에 있는 원소들은 처음 시작할 때 모조리 지워도 상관없습니다. 따라서, 맨 처음 원소는 X이며, 이 원소는 절대적으로 마지막에 지우는 것으로 고정하겠습니다.

 위의 세팅에 의해서, 어떤 두 Z가 있다면, 앞에 있는 것을 먼저 지우는 것이 이득입니다. 앞에 있는 Z 바로 뒤에 Y가 따라온다면, 뒤에 있는 Z를 먼저 지운다고 할 때 그런 Y를 처리할 수 없지만, 뒤에 있는 Z를 나중에 지운다고 해도 앞에 있는 Z가 존재해서 얻을 수 있는 좋은 제거의 수에는 아무런 영향이 없기 때문입니다.

첫 번째 X와 첫 번째 Z 사이의 원소들 X,Y에 대해서 생각해보면, 무조건 그들중 가장 마지막 것들부터 순서대로 제거하는 것이 이득입니다. 좋은 제거를 얻기 위해서는 제거하는 원소 뒤에 Z가 반드시 존재해야 하기 때문입니다.

 이 두 아이디어를 종합하여, 첫 번째 원소부터 확인하면서 만약 X,Y를 만난다면 stack에 넣어주고, Z를 만난다면 stack의 뒷쪽 원소부터 제거해주고 Z까지 제거해주는 알고리즘을 생각할 수 있으며, 실제로 이것이 최적입니다. 물론, 맨 처음 등장하는 X는 예외적으로 가장 마지막에 제거되어야 합니다.

위 알고리즘을 사용하면 L=200000일때의 문제를 해결할 수 있습니다.
+ ## Subtask 2. ( $L=160000, 40$점)
문자는 세 종류이기 때문에, 두 비트를 통해 세 종류를 나타내는것보다는 더 효과적으로 정보를 보내는 방법이 존재합니다. 예를 들어, 문자 5개(=243가지)를 8비트(=256가지)에 보내는 방법이 가능하며, 이를 구현하면 L=160000일때를 해결할 수 있습니다.
+ ## Subtask 2. ( $L=100000, 70$점)
위의 알고리즘에서 중요한 것은, X와 Y를 구분하지 않아도 저절로 좋은 제거의 수가 최대가 된다는 점입니다. 따라서 첫 번째 X보다 앞의 원소와, Z들을 0으로, 나머지를 1로 표기하여 정보를 보내주면 L=100000에 문제를 해결하는데에 필요한 정보를 보낼 수 있습니다.
+ ## Subtask 2. ( $L=70000, 100$점)
사실, 위의 알고리즘에서는 모든 Z에 대해서 stack을 초기화하였지만, 굳이 모든 Z에 대해서 시행하는것만이 최적은 아닙니다. 여러 Z가 동시에 인접해있다면, 그들중 가장 마지막 Z에 대해서만 해당 시행을 취해도 좋은 시행의 수가 변하지 않음은 직관적으로 알 수 있습니다. 따라서 여러 Z가 인접해있다면, 그중 가장 마지막 원소만을 0으로, 나머지를 1로 표기하고, 추가로 첫 번째로 X가 등장하는 위치는 이진수로 인코딩하여 보내줍니다.

 이 표기의 중요한 성질은, X를 인코딩하기 위해 쓴 약간의 비트를 제외하면 연속하는 0이 존재하지 않는다는 것입니다. 즉, 이 수열 자체를 어떤 거대한 정수의 제켄도르프 표현으로 해석할 수 있으며, 따라서 수열을 몇 개의 부분으로 쪼갠 뒤, 해당 부분의 0이 켜진 위치들에 대해 그 위치의 피보나치 수열의 값을 더해주고, 이를 이진법으로 나타낸 정수로 변환하여 대체된 수열을 만들어서 Bruno에게 보내줍니다. 반대로 Bruno는 받은 정수를 제켄도르프 표현으로 변환한 뒤 Anna가 보내고자 하였던 문자열이 무엇인지 알 수 있습니다.

 이 표현의 대략적인 효율은 10만을, 피보나치 수열의 대략적 증가율인 황금비를 나눈 값이 됩니다. 그 값이 대략적으로 6만대가 되기 때문에 기본적으로 해당 방식이 효과를 볼 것이라 추측할 수는 있습니다. 수열을 몇 개의 부분으로 나눌 때, 해당 부분이 과도하게 작으면 효율 측면에서 실패하기 때문에 적절한 크기의 부분으로 나누어서 정보를 변환하는 것이 중요합니다. 대략 길이가 63인 여러개의 부분들로 나눈 다음에 전달하면 아슬아슬하게 7만바이트보다 작습니다.
