# Ancient Machine(joisc 2021)
# 문제
안나와 브루노는 고고학자입니다. 그들은 IOI 왕국의 폐허를 탐사합니다. 폐허 A에서 Anna는 오래된 기계의 설계도를 발견했습니다. 
폐허 B에서 브루노는 실제 기계를 발견했습니다.

이 기계는 N개의 장치로 구성되어 있습니다. 장치는 일렬로 전선에 부착됩니다. X, Y, Z라는 세 가지 유형의 장치가 있습니다. 
왼쪽부터 0부터 N − 1까지 장치 번호가 매겨져 있습니다. 장치 \(i(0 ≤ i ≤ N − 1)\)의 유형은 \(S_i\)입니다. 즉, \(S_i\)는 X, Y 또는 Z입니다.

기계가 너무 크기 때문에 Bruno는 기계에서 장치를 하나씩 제거하기로 결정했습니다. 그러나 장치들은 전선을 통해 서로 상호작용하기 때문에 
제거 순서에 매우 주의해야 한다.

기계에서 장치를 제거하는 방법과 관련하여 다음을 정의합니다.

장치 \(x, y,z(0 ≤ x < y < z ≤ N − 1)\)가 아직 제거되지 않았고 \(S_x = X, S_y = Y, S_z = Z\)라고 가정합니다. 또한 모든 \(x < j < y\)인 j에 대해 장치 j가 이미
제거되어있었다고 합시다. 또한, 모든 \(y < k < z\)에 대해 장치 k가 이미 제거되었다고 합시다. 이러한 조건이 모두 충족될 때 장치 y를 기계에서 제거하면 
이를 좋은 제거라고 합니다.
기계에서 장치를 제거하는 다른 방법은 좋은 제거가 아닙니다.
Bruno는 제거 가능한 횟수가 최대가 되도록 기계에서 N개의 장치를 모두 제거해야 합니다. 그러나 세 가지 유형의 장치는 유사해 보이기 때문에 장치 유형을 구별할 수 없습니다.

Anna는 기계의 설계도를 알고 있으므로 기계에 연결된 각 장치의 유형을 알고 있습니다. 따라서 그녀는 브루노를 돕기 위해 송신기를 사용할 것입니다. 송신기를 사용하여 
일련의 문자를 보낼 수 있습니다. 그녀가 보낼 수 있는 각 문자는 0 또는 1입니다.

Anna의 전략과 Bruno의 전략을 구현하여 좋은 제거 횟수가 최대가 되도록 프로그램을 작성하세요. 안나가 브루노에게 보낸 문자 수가 적을수록 더 높은 점수를 
얻게 됩니다.
# 구현
두 개의 파일을 제출해야 합니다.

첫 번째 파일은 Anna.cpp입니다. Anna의 전략을 구현해야 합니다. 다음 함수를 구현해야 합니다. 프로그램은 전처리 지시문 #include를 사용하여 Anna.h를 포함해야 합니다.

void Anna(int N, std::vector<char> S)
각 테스트케이스에 대해 이 함수는 처음에 정확히 한 번 호출됩니다.
파라미터 N은 장치의 개수 N입니다.
파라미터 S는 길이 N의 배열입니다. 이는 S[i]가 장치 i의 유형 \(S_i(0 ≤ i ≤ N − 1)\)임을 의미합니다. 여기서 문자 S[i]는 'X', 'Y' 또는 'Z'입니다.
프로그램은 다음 함수를 호출할 수 있습니다.

void Send(int a)
이 함수를 호출하여 Anna는 0 또는 1이라는 문자를 Bruno에게 보냅니다.
파라미터 a는 브루노에게 보내는 정보입니다. 0 또는 1이어야 합니다. 이 조건을 만족하지 않으면 프로그램은 오답[1]으로 판단됩니다.
Send 함수는 200,000회 이상 호출하면 안 됩니다. 200,000회 이상 호출되면 해당 프로그램은 오답[2]으로 판단됩니다.
두 번째 파일은 Bruno.cpp입니다. 브루노의 전략을 실행해야 합니다. 다음 함수를 구현해야 합니다. 프로그램은 전처리 지시문 #include를 사용하여 Bruno.h를 포함해야 합니다.

void Bruno(int N, int L, std::vector<int> A)
Anna 함수가 호출된 후 이 함수는 정확히 한 번 호출됩니다.
파라미터 N은 장치의 개수 N입니다.
파라미터 L은 Anna가 보낸 문자 수 L(0 또는 1)입니다.
파라미터 A는 길이 L의 배열입니다. 이는 Anna가 순서대로 문자 A[0],A[1],...,A[L-1]을 Bruno에게 보냈다는 의미입니다. 배열의 각 문자는 0 또는 1입니다.
프로그램은 다음 함수를 호출할 수 있습니다.

void Remove(int d)
이 함수를 호출하면 프로그램이 장치를 제거하는 방법에 대해 응답합니다.
매개변수 d는 장치의 인덱스입니다. 이는 브루노가 장치를 제거했다는 의미입니다.
부등식 $$ 0 ≤ d ≤ N − 1 $$이 충족되어야 합니다. 이 조건이 만족되지 않으면 귀하의 프로그램은 오답[3]으로 판단됩니다.
동일한 매개변수 d를 사용하여 이 함수를 두 번 이상 호출하는 것은 허용되지 않습니다. 이 조건이 만족되지 않으면 귀하의 프로그램은 오답[4]으로 판단됩니다.
Remove 함수는 정확히 N 번 호출되어야 합니다. Bruno 함수가 종료되었을 때 Remove 함수 호출 횟수가 N회와 다르면 해당 프로그램은 오답[5]으로 판단됩니다.
N개의 장치를 모두 제거한 후 제대로 제거되는 횟수는 가능한 최대값이어야 합니다. 이 조건이 만족되지 않으면 귀하의 프로그램은 오답[6]으로 판단됩니다. 
   
# 입력
샘플 그레이더는 다음과 같은 형식으로 데이터를 읽습니다.
<table>
  <tr>
    <td>
      $$ N $$ 
      $$ S_0 S_1 ... S_{N-1} $$
    </td>
  </tr>
</table>
   
이때 \(S_i, S_{i+1}\)은 공백으로 분리되어 있습니다.
# 출력
프로그램이 성공적으로 종료되면 샘플 그레이더는 다음 정보를 표준 출력에 씁니다. 
(실제 따옴표는 쓰지 않습니다.)   
   
+ 프로그램이 오답으로 간주되면 샘플 그레이더는 해당 유형을 “틀렸습니다[1]” 형식으로 작성하고 
종료합니다.   
+ Alice와 Bob에 대한 호출 중 하나라도 잘못된 답변으로 간주되지 않으면 샘플 그레이더는 
"Accepted"라고 씁니다. 또한 V의 값을 출력합니다.   
+ 귀하의 프로그램이 여러 유형의 오답으로 간주되는 경우 샘플 그레이더는 그 중 하나만 보고합니다.
# 제한
$1 ≤ N ≤ 1 000$.   
$0 ≤ M ≤ N(N − 1)/2$.   
$0 ≤ A_i ≤ N − 1 (0 ≤ i ≤ M − 1)$.   
$0 ≤ B_i ≤ N − 1 (0 ≤ i ≤ M − 1)$.   
$A_i ≠ B_i (0 ≤ i ≤ M − 1)$.   
$(A_i, B_i) ≠ (A_j, B_j) and (A_i, B_i) ≠ (B_j, A_j) (0 ≤ i < j ≤ M − 1)$.   
# 점수
서브태스크 1 또는 서브태스크 2에서 프로그램이 모든 테스트케이스를 해결하면 만점을 얻습니다.   
서브태스크 3에서 프로그램이 모든 테스트케이스를 해결하면 점수는 다음과 같이 계산됩니다. MaxDiff를
V − N의 최대값으로 설정합니다.   
101 ≤ MaxDiff일 때 점수는 0입니다.   
21 ≤ MaxDiff ≤ 100일 때 점수는 $13 + [(100 − MaxDiff)/4]$입니다. 여기서 [x]는 x를 초과하지 않는
가장 큰 정수입니다.   
13 ≤ MaxDiff ≤ 20일 때 점수는 $33 + (20 − MaxDiff) × 3$입니다.   
MaxDiff가 12 이하이면 점수는 63입니다.   
## 예제
다음은 샘플 그레이더에 대한 샘플 입력과 그에 대응되는 함수의 호출입니다.   
<table>
  <tr>
    <td rowspan="2">예시 입력1</td>
    <td colspan="4">예시 호출</td>
  </tr>
  <tr>
    <td>호출</td>
    <td>반환</td>
    <td>호출</td>
    <td>반환</td>
  </tr>
  <tr>
    <td rowspan="20">4 3<br/>0 1<br/>0 2<br/>0 3<br/></td>
    <td> Alice(...)</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
  <td></td>
  <td>InitG(4,3)</td>
  <td></td>
  </tr>
  <tr>
    <td></td>
  <td></td>
  <td></td>
  <td>(none)</td>
  </tr>
  <tr>
    <td></td>
  <td></td>
  <td>MakeG(0,0,1)</td>
  <td></td>
  </tr>
  <tr>
    <td></td>
  <td></td>
  <td></td>
  <td>(none)</td>
  </tr>
  <tr>
    <td></td>
  <td></td>
  <td>MakeG(1,0,2)</td>
  <td></td>
  </tr>
   <tr>
    <td></td>
  <td></td>
  <td></td>
  <td>(none)</td>
  </tr>
    <tr>
    <td></td>
  <td></td>
  <td>MakeG(2,0,3)</td>
  <td></td>
  </tr>
     <tr>
    <td></td>
  <td>(none)</td>
  <td></td>
  <td></td>
  </tr>
      <tr>
    <td>Bob(...)</td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
      <tr>
    <td></td>
  <td></td>
  <td>InitMap(4,3)</td>
  <td></td>
  </tr>
    <tr>
    <td></td>
  <td></td>
  <td></td>
  <td>(none)</td>
  </tr>
    <tr>
    <td></td>
  <td></td>
  <td>MakeMap(0,1)</td>
  <td></td>
  </tr>
    <tr>
    <td></td>
  <td></td>
  <td></td>
  <td>(none)</td>
  </tr>
     <tr>
    <td></td>
  <td></td>
  <td>MakeMap(0,2)</td>
  <td></td>
  </tr>
     <tr>
    <td></td>
  <td></td>
  <td></td>
  <td>(none)</td>
  </tr>
      <tr>
    <td></td>
  <td></td>
  <td>MakeMap(0,3)</td>
  <td></td>
  </tr>
     <tr>
    <td></td>
  <td></td>
  <td></td>
  <td>(none)</td>
  </tr>
      <tr>
    <td></td>
  <td>(none)</td>
  <td></td>
  <td></td>
  </tr>
</table>

이 경우 Alice(...), Bob(...) 함수에 입력되는 매개변수는 다음과 같습니다.   
<table>
   <tr>
      <td>파라미터</td>
      <td>Alice(...)</td>
      <td>Bob(...)</td>
   </tr>
   <tr>
      <td>N</td>
      <td>4</td>
      <td></td>
   </tr>
   <tr>
      <td>M</td>
      <td>3</td>
      <td></td>
   </tr>
   <tr>
      <td>V</td>
      <td></td>
      <td>4</td>
   </tr>
   <tr>
      <td>U</td>
      <td></td>
      <td>3</td>
   </tr>
   <tr>
      <td>A</td>
      <td>{0,0,0}</td>
      <td></td>
   </tr>
   <tr>
      <td>B</td>
      <td>{1,2,3}</td>
      <td></td>
   </tr>
   <tr>
      <td>C</td>
      <td></td>
      <td>{2,2,2}</td>
   </tr>
   <tr>
      <td>D</td>
      <td></td>
      <td>{3,0,1}</td>
   </tr>
</table>

# 서브태스크
|번호|배점|제한|
|---|---|---|
|1|22|$N \le 10$|
|2|15|$N \le 40$|
|3|63|추가 제약조건이 없습니다.|
+ ## Subtask 1,2. ( $37점$)
 다양한 풀이가 있을 수 있습니다. 추후 풀이로 확장하기 가장 쉬운 풀이는, 그래프의 정점들을 특정한 방식으로 구분하는 풀이입니다. 정점들은 많아야 40개이고 하나의 정점과 연결된 기존의 간선들도 많아야 39개이기 때문에, 예를 들어 1000개의 새로운 정점을 추가한 뒤, 1번 정점을 50개의 새로운 정점과 연결하고, 2번 정점을 100개의 새로운 정점과 연결하고, ..., 10번 정점을 500개의 새로운 정점과 연결하는 방식을 쓰고, 각 새로운 정점들은 서로 연결했다고 해봅시다. 그렇다면 정점의 번호가 사라져도 새로 추가된 정점을 구분할 수 있고, 새로 추가된 간선에 의한 차수를 계산하면 각 정점들이 기존에는 몇번 정점이었는지 알아낼 수 있습니다.
+ ## Subtask 3. ( $100점$)
 위의 풀이에서는 기존의 정점들을 분간해내기 위해 i번 정점에 $k *i$개의 정점을 새로 연결해주었지만, 사실 굳이 선형적인 방식으로 정점을 연결해줄 필요는 없습니다. 왜냐하면 새로운 정점들과 간선들을 적당히 추가하면, 새로운 정점들끼리 구분되도록 할 수 있기 때문입니다. 그렇다면, 어떤 방법을 써야 새로운 정점들을 알아내면서, 그들에게 매겼던 번호도 알아낼 수 있을까요?
 한 가지 생각해볼 수 있는 것은, 이를테면 다음과 같은 방법입니다:
 1. 정확히 하나의 정점을 제외하고 모든 다른 정점들과 연결된 정점(A)과, 연결되지 않은 정점(B) 두 개를 집어넣습니다(이후에 추가하는 정점들과도 연결되어있습니다)
 2. B와 기존에 존재했던 어떤 정점 사이에도 연결은 존재하지 않습니다.
 3. 새로운 10개의 정점들을 추가하는데, 이들끼리는 특정한 트리의 구조로 연결되어있습니다. 또한, B와 이 10개의 정점들을 전부 연결해줍니다.
 4. 새로 추가한 10개의 정점들중 i번째 정점에 대해서, 기존 정점의 i번째 비트가 켜져있다면 해당 정점과 연결합니다.

 이제 이러한 세팅하에서 어떤 방식으로 문제가 풀릴지 생각해봅시다.   
 일단, 첫번째로 지정한 정점인 A는 무조건 찾아낼 수 있습니다. A의 차수는 (전체 정점의 개수-2)입니다. 3번째 스텝에서 추가한 정점들은 트리와 같이 연결되어있기 때문에, 적어도 3개의 정점들에 대해서는 간선이 없습니다. 따라서 용의선상에서 제외됩니다. 2번 스텝에서 추가한 정점의 경우에는, (기존 정점의 개수+1(A)+1(자신))만큼의 정점들과 연결되지 않는데, 따라서 차수가 (전체 정점의 개수-3) 이하입니다. 따라서 B도 아닙니다. 기존에 존재했던 정점들의 경우에는 i번 정점의 경우 (전체 정점의 개수-(10-(i의 켜진 비트수))-2) 이하의 차수를 가지게 되는데, 10개의 비트가 켜진 i는 존재하지 않기 때문에 이들도 조건을 만족할 수 없습니다. 따라서 오로지 A만이 최대 차수를 가집니다.   
 A를 구분했기 때문에, 이제 B도 알아낼 수 있습니다. B를 알아내었다는 것은, B와 연결된 10개의 정점들을 알아낼 수 있음을 의미합니다. 만약 10개의 정점들을 연결한 트리의 상태가 굉장히 비대칭적이라면, 각 정점들이 몇번이었는지 또한 알아낼 수 있을 것입니다(알아내었다고 가정해봅시다.). 그렇다면, 총 10개의 정점이 있으므로 기존의 정점들을 1023번째까지를 표현할 수 있고, 이는 전체 문제의 제한인 1000을 넘으므로 문제가 해결됩니다!   
 비대칭 트리를 구성하는 방법은 몇가지가 있을 수 있는데, 한 가지 방법은 다음과 같습니다:   
(1,2)   
(2,3)   
(3,4)   
(4,5)   
(5,6)   
(6,7)   
(1,8)   
(1,9)   
(9,10)  
실제로 해당 간선들을 통해 트리를 그려보면, 1만이 3의 차수를 가지고 그로부터 파생되는 각 가지들의 길이가 서로 다름을 알 수 있습니다. 따라서 각 가지를 특정할 수 있고, 그 가지에 들어있는 정점들도 구분할 수 있습니다.
