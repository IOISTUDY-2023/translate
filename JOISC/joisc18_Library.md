# Library(joisc 2018)
# 문제
수백년이 지난 후, JOI 도시는 폐허가 되었습니다. 탐험가인 IOI쨩은 도서관이 지어졌던 곳을 탐험하고 있습니다.   
탐험의 결과, 다음과 같은 사실이 알려졌습니다:   
+ JOI 도시의 도서관의 선반에는 N개의 책이 있었습니다. N개의 책들은 왼쪽에서 오른쪽으로 배열되어 있었습니다.   
+ N개의 책들은 1부터 N까지 번호가 매겨져있었습니다. 그러나 그것이 선반에서의 번호와 일치하지는 않습니다.   
+ 한 번의 연산을 통해, 선반에서 연속한 몇 개의 책들을 고를 수 있습니다.   
 불행히도, IOI쨩은 도서관의 고서들을 찾을 수 없었습니다. 그러나 그녀는 도서관의 선반에서 일어났던
연산들을 담당했던 기계를 발견했습니다. 만약 우리가 몇 개의 책들의 번호를 기계에 집어넣으면,
이 기계는 선반에서 책을 가져오는데 필요한 연산의 최소 횟수를 반환합니다.   
   
IOI쨩은 기계에 몇개의 질문을 함으로써 선반의 책들의 순서를 알고자 합니다. 그러나,
만약 선반에 대해 모든 책들의 순서가 반대여도 구분이 불가능하기 때문에, 그녀가 찾는 책의 순서는
좌우를 따지지 않습니다.   
   
기계가 낡았기 때문에, 많아야 20000번의 질문을 할 수 있습니다.   
   
기계에 많아야 20000번의 질문을 해서 책의 순서를 알아내는 프로그램을 작성하십시오. 좌우구분을 맞을
필요는 없습니다.   
# 구현
하나의 파일을 제출해야 합니다.   
   
파일의 이름은 library.cpp입니다. 다음 기능을 구현해야 합니다.   
프로그램에는 library.h가 포함되어야 합니다.   
   
void Solve(int N)   
각 테스트 사례에 대해 이 함수는 한 번 호출됩니다.   
매개변수 N은 책장에 있는 책의 수 N입니다.   
프로그램은 다음 함수를 호출할 수 있습니다.   
   
int Query(const std::vector<int>& M)   
​​​​​​​하나 이상의 책이 번호로 지정된 경우 이 함수는 책장에서 해당 책만 가져오는 데 필요한
최소 작업 수를 반환합니다.   
책장에서 가져온 책은 크기 N의 벡터인 매개변수 M으로 지정됩니다.   
각 $i(1 ≤ i ≤ N)$에 대해 M[i-1] = 0이면 책 i는 책장에서 가져오지 않습니다.   
M[i-1] = 1이면 책 i를 책장에서 꺼냅니다. M의 크기가 N과 다르면 프로그램은 틀렸습니다[1]으로
간주됩니다. 각 i에 대해 M[i-1]은 0 또는 1과 같아야 합니다. M[i-1] = 1인 $i(1 ≤ i ≤ N)$가 
하나 이상 존재해야 합니다. 이 둘 중 하나라도 조건이 만족되지 않으면 
프로그램은 틀렸습니다[2]으로 간주됩니다. Query 함수가 20,000회 이상 호출되면 프로그램은
틀렸습니다[3]으로 간주됩니다.   
void Answer(const std::vector<int>& res)   
​​​​​​​이 ​​기능을 사용하면 프로그램이 책장에 있는 책의 순서에 응답합니다. 책이 왼쪽에서 오른쪽으로
놓였는지, 오른쪽에서 왼쪽으로 놓여졌는지 지정할 필요는 없습니다.   
res 매개변수는 크기 N의 벡터입니다. 책장에 있는 책의 순서를 설명합니다. 각 $i(1 ≤ i ≤ N)$에
대해 책장의 왼쪽에서 i번째 책의 번호는 res[i-1]입니다. res의 크기가 N과 다른 경우 프로그램은
틀렸습니다[4]으로 간주됩니다. res[i-1]은 1과 N 사이의 정수여야 합니다. 이 조건이 만족되지 않으면
프로그램은 틀렸습니다[5]으로 간주됩니다. 또한 정수 res[0], res[1],. . ., res[N-1]은 서로
달라야 합니다. 이 조건이 만족되지 않으면 프로그램은 틀렸습니다[6]으로 간주됩니다.
Solve 함수가 종료되었을 때 Answer 함수 호출 횟수가 1회와 다를 경우 해당 프로그램은
틀렸습니다[7]로 간주됩니다.   
   
Solve 함수에서 지정한 책의 순서가 책장에 있는 책의 순서와 다를 경우 프로그램은
틀렸습니다[8]으로 간주됩니다. 책이 왼쪽에서 오른쪽으로 놓였는지, 오른쪽에서 왼쪽으로 놓여졌는지
지정할 필요는 없습니다.   
    
# 제한
$1 ≤ N ≤ 1 000.$   
$1 ≤ A_i ≤ N(1\le i \le N).$   
$A_i\neq A_j(1\le i\lt j\le N).$   
## 예제
다음은 샘플 그레이더에 대한 샘플 입력과 그에 대응되는 함수의 호출입니다.   
<table>
  <tr>
    <td rowspan="2">예시 입력1</td>
    <td colspan="4">예시 호출</td>
  </tr>
  <tr>
    <td>호출</td>
    <td>반환</td>
    <td>호출</td>
    <td>반환</td>
  </tr>
  <tr>
    <td rowspan="6">5<br/>4<br/>2<br/>5<br/>3<br/>1</td>
    <td> Solve(5)</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
  <td></td>
  <td>Query( { 1,1,1,0,0 } )</td>
  <td></td>
  </tr>
  <tr>
    <td></td>
  <td></td>
  <td></td>
  <td>2</td>
  </tr>
  <tr>
    <td></td>
  <td></td>
  <td>Answer( { 4,2,5,3,1 } )</td>
  <td></td>
  </tr>
  <tr>
    <td></td>
  <td></td>
  <td></td>
  <td>(none)</td>
  </tr>
  <tr>
    <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
</table>

이 문제에서, 책들이 오른쪽에서 왼쪽으로 배치되었는지, 혹은 반대인지를 구분할 필요는 없습니다.   
따라서 당신의 프로그램은 매개변수가 뒤집힌 Answer({1,3,5,2,4})를 호출해도 정점으로 간주됩니다.   
# 서브태스크
|번호|배점|제한|
|---|---|---|
|1|19|$N \le 200$|
|2|81|추가 제약조건이 없습니다.|
+ ## Subtask 1. ( $19점$)
굉장히 다양한 풀이가 있을 수 있습니다. 한 가지 생각해볼 수 있는 단순한 방법은, 모든 두 책의 쌍에
대해서 쿼리를 날려보는 것입니다. 그렇게 하면 각 책들의 연결성을 알 수 있고, 따라서 좌우반전을
제외하고는 답을 알아낼 수 있습니다.   
+ ## Subtask 2. ( $100점$)
 서브태스크 1의 방법을 사용하기에는 과도하게 많은 쿼리 횟수가 필요하므로, 조금 더 빠르게 문제를 풀 수 있는 방법을 생각해야 합니다.   
 한 가지 생각해볼 수 있는 방법은 어떤 책과 인접한 다른 책을 빠르게 찾아내는 것입니다.   
우선 한 가지 알아야 하는 사실은 특정한 책들의 번호의 집합 $A$가 있고 그 여집합 $B$가 있다고 할 때, 다음과 같은 사실이 성립한다는 점입니다.
참고로, 1과 n이라 함은 선반을 기준으로 한 번호를 의미합니다. 즉, 양 끝 책들을 의미합니다.   
+ 만약 1 혹은 n이 $A$에 포함된다면, Query(A)>=Query(B)이며, 역도 성립한다.<br/>

즉, 아직까지 탐색되지 않은 책들의 끝부분들을 차례차례 찾아나가는 방식으로 풀이를 할 생각을 할 수 있습니다. 이러한 방식이 성립하는 이유는,
선반의 가장 끝부분에 있는 책을 찾아낸 뒤 그 책을 제거하고 나면 크기가 하나 작아진 똑같은 문제를 해결해서 아직까지 규명된 적 없는,
선반 내에서 연속한 책들에 대해 동일한 문제를 다시 풀 수 있고, 그곳에서 발견한 끝부분이 지금까지 탐색된 책들을 기준으로 어디에 있는지는 단순히
한 번의 쿼리를 통해 연결성을 판별하면 되기 때문입니다.<br/>
따라서, 목표는 초기 상태에서 선반의 끝부분에 있는 책을 충분히 빠르게(대략 $O(log n)$에) 해결하는 것입니다. 이는 어떻게 할 수 있을까요?   <br/>
잘 생각해보면, 이는 이분탐색을 통해 처리할 수 있음을 알 수 있습니다. 위에서 발견했던 성질을 여기에서 활용하게 되는데, 특정한 책들의 집합 내에
1 혹은 n이 존재하는지에 대한 판별을 할 수 있기 때문입니다. 그렇다면 대략적으로 탐색을 하는 과정은 다음과 같을 것입니다:   <br/>
  처음에는 탐색되지 않은 모든 책들을 A에 집어넣고, A의 크기의 대략 절반인 아무 부분집합 A'을 잡고, A'에 1 혹은 n이 있는지 판별합니다.   <br/>
  만약 1 혹은 n이 존재한다면, A=A'으로 세팅하고, 그렇지 않다면 A-=A'를 진행합니다.   <br/>
 이러한 방식의 이분탐색을 진행하면 마지막에는 1과 n 둘 중 하나를 얻을 수 있고, 우리의 목표가 달성되었습니다.   <br/>
앞서 말한 방식으로 문제의 크기를 1씩 줄여나가면서 해결해주면 전체 답을 얻을 수 있습니다. 하나의 끝을 발견하는데에 대략 $2 log n + 1$정도의 쿼리가
사용되긴 하지만, 항상 저만큼의 쿼리가 소요되는 것은 아니고 문제의 크기가 줄어듦에 따라 소모가 점진적으로 나아지기 때문에 쿼리 제한을 초과하는 문제에 직면하진 않습니다.
