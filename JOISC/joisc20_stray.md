# Stray Cat(Joisc 2020)
# 문제
Anthony는 그래프를 입력받고, 그래프의 각 간선에 $0 ~ A-1$ 까지의 수를 적는다. 모든 간선에 수를 전부 적은 이후, Catherine은 한 정점에서 시작해서 0번 정점으로 이동해야 하는데, 현재 자신이 위치한 정점을 연결하는 간선의 종류만을 알 수 있다. Catherine의 0번 정점으로 이동하는데에 소요되는 이동횟수는 $d$가 Catherine의 현재 위치와 0번 정점까지의 최단거리일 때, $d+B$회 까지 이동 가능하다.
+ ## Subtask 1,3. ($ 4점 $)
+ 주어지는 그래프가 트리 구조이며, $A=3$인 경우이다. 
+ Anthony는 0번 정점을 루트 노드로 하여, 각 자식 노드들의 정점의 깊이를 계산한다. 이후, 0번 정점을 제외한 정점 $X$ 과 그 부모노드를 잇는 간선에 $dep(X)%3$을 적는다.
+ Catherine이 어떤 정점 $X$에 있었다고 하자. 두 가지 경우의 수가 존재한다.
+ 1. $X$와 연결된 간선의 종류가 정확히 하나 존재하는 경우: 이 경우 $X$가 트리의 리프임은 자명하기 때문에, 위로 올라가기 위해 그 간선을 선택하면 된다.
+ 2. $X$와 연결된 간선의 종류가 정확히 2개 존재하는 경우: 반드시 어떤 0~2 사이의 수 $k$에 대해서, $X$와 연결된 간선의 종류는 $k$, $(k+1)%3$ 둘임을 알 수 있다. 또한, 간선에 적힌 것은 자식 노드의 깊이이므로, 무조건 깊이가 더 작은 정점에 의해서 칠해졌을 $k$가 적힌 간선쪽으로 올라가면 된다는 사실을 알 수 있다.
+ ## Subtask 1,2. ($ 4점 $)
+ 그래프가 주어지며, $A=4$이다.
+ Subtask 1,3을 해결한 것과 유사한 논리를 사용할 것이다. 우선, Anthony는 0번 정점을 기준으로 bfs spanning tree를 찾아낸다. 이후, bfs spanning tree에 속하지 않은 모든 간선들에 3을 적고, bfs spanning tree에 대해서는 Subtask 1,3에서 진행한 행동을 동일하게 적용한다. 이렇게 bfs를 통해 그래프를 만들 경우, 무조건 어떤 정점과 루트 사이의 거리가 최소가 됨은 잘 알려져 있다.
+ Catherine은 단순히 3번 간선을 완벽히 무시하고 진행하면 된다.
+ ## Subtask 1,2,3,4. ($ 15점 $)
+ 그래프가 주어지며, $A=3$이다.
+ Subtask 1,2에서 사용하지 않은 간선을 더 잘 색칠할수는 없을까? 우선, bfs spanning tree에 대해서 다음과 같은 성질을 알아야 한다:
+ 임의의 간선이 연결하는 두 정점은 bfs spanning tree 내에서 깊이 차이가 2 이상일 수 없다. 만약 1을 초과하는 차이가 난다면, 그 간선이 bfs spanning tree를 이루는 데에 사용되지 않음이 모순이기 때문이다.
+ Anthony가 Subtask 1,2에서 bfs spanning tree에 속하지 않는 어떤 간선을 색칠하려 한다고 하고, 그 간선이 잇는 정점이 $X$, $Y$라고 하자. 일반성을 잃지 않고 $dep(X)<=dep(Y)$라고 할 때, 해당 간선에는 $dep(X)(mod 3)$을 적는다.
+ Catherine는 Subtask 1,3의 전략을 동일하게 적용하면 된다. 이것이 가능한 이유는 한 정점을 잇는 간선의 종류가 많아야 2개이며, 그중 하나는 반드시 자신보다 깊이가 얕은 정점과 연결되어있기 때문이다.
+ ## Subtask 5. ($ 5점 $)
+ 주어지는 그래프가 트리 구조이며, $A=2$이며, $B=2N$인 경우이다.
+ Subtask 1,3에서 했던 것과 유사하게, Anthony는 0번 정점을 기준으로 각 정점의 깊이를 계산한 다음, 간선이 잇는 더 깊은 정점의 깊이를 2로 나눈 나머지를 적는다.
+ Catherine의 첫 위치를 $X$라고 하자. Catherine의 전략은 경우에 따라 다음과 같이 나타난다:
+ 1. $X$와 연결된 간선의 종류가 1개일 때. 이 경우에는 $X$가 리프노드임을 확신할 수 있기 때문에 자신과 연결된 간선은 반드시 루트노드와 가까워지는 방향이며, 다음으로 도착하는 모든 정점들에 대해서도 어떤 간선이 부모노드로 가는 간선인지를 알기 때문에 이 시점부터는 무조건 해결이 가능하다.
+ 2. 그 외의 경우. Catherine이 가지고 있는 정보는 $X$가 리프가 아니라는 정보 뿐이다. 이 경우, 아무 숫자의 간선부터 탐색을 진행하면서 다음 정점으로 넘어갈 때마다 선택할 간선의 종류를 바꿔준다. 이렇게 진행할 경우 루트 노드에 도달하거나, 혹은 리프에 도달하게 된다. 루트 노드에 도달한다면 문제가 해결된 것이고, 리프 노드에 도달한다면 1번 케이스로 돌아가 해결하면 된다.
+ 최악의 경우는 리프노드에 도달한 다음 루트 노드로 가는 것인데, 이 경우 이동횟수가 $B$를 넘을 일은 절대 없기 때문에 가능하다.
+ ## Subtask 5,6. ($ 76점 $)
+ 주어지는 그래프가 트리 구조이며, $A=2$이며, $B=12$인 경우이다.
+ 직관적으로 생각해보면 상수번 만큼 이동하다가, 자신의 이동이 루트와 멀어진다는 것을 판별하고 바로 역행을 하거나 자신이 올바른 방향으로 가고 있다는 확신을 얻어야만 문제가 해결됨을 알 수 있다.
+ 그러나, 우리가 기존에 간선을 색칠할 때 사용했던 0 1 0 1 0 1은 이러한 측면에서 어떤 정보도 제공하지 않는다.
+ 이런 대칭성을 제거할 수 있으면서, 가능한 한 반복이 짧은 이진 수열에는 어떤 것이 있을까?
+ 0 1 0 0 1 1 0 1 0 0 1 1....의 경우에는 판별이 가능하다(즉, 뒤집으면 다른 수열이 나온다.). 예외적으로, 만약 자식 노드가 2개 이상인 정점에 "루트 노드와 가까워지는 방향으로" 도달하게 될 때에는 무조건 루트 노드와 가까워지는 쪽과는 다른 숫자로 자식들을 연결하는 간선을 채우자.
+ 즉, Anthony가 해야 할 일은 다음과 같다:
+ dfs를 진행하면서, 현재 탐색중인 정점을 $X$라고 하고, $X$와 그 부모 정점을 잇는 간선에 적힌 수를 $k$라고 하자.
+ 1. $X$의 자식이 2개 이상일 경우: $X$의 자식노드를 잇는 간선을 $1-k$로 칠한다.
+ 2. $X$의 자식이 1개인 경우: 그 뒤로 쭉 각 정점들의 노드가 1개인 경우를 생각하자. $X$의 위에 칠해진 $k$와 모순되지 않게, 0 1 0 0 1 1을 연속적으로 칠한다. 이를 구현하는 방법은, 자식이 1개인 각 정점들에 $0~5$까지의 인덱스를 부여한 채로 dfs를 진행하는 것이다.
+ Catherine은 처음으로 움직일 간선의 숫자를 정한 후, 계속 움직인다. 만약 도중에 어떤 정점과 연결된 간선의 종류가 2개가 나온다면, 현재까지 잘 진행하고 있음을 의미하기 때문에 이 시점부터는 탐색할 간선의 숫자를 계속 바꿔가면서 탐색만 해도 루트 노드에 도달 가능하다. 반대로 총 간선의 개수는 3 이상인데 간선의 종류가 하나밖에 없다면 현재 Catherine이 역주행을 하고 있음을 의미하기 때문에, 바로 반대 방향으로 이동해서 루트로 이동 가능하다.
+ 만약 자식이 1개 이하인 정점들만으로 총 6회 움직였다고 생각하자. 이 경우 현재까지 지나온 간선들에 적힌 수의 배열을 알 수 있고, 이것이 0 1 0 0 1 1의 일부인지, 혹은 이를 뒤집은 수열의 일부인지를 판별해서 자신이 옳은 방향으로 가고 있는지, 혹은 역주행을 하고 있는지 알아낼 수 있다.
+ 역주행을 할 수 있는 횟수는 많아야 6회이므로, 많아야 12번 초과로 움직이게 된다.
+ ## Subtask 5,6,7. ($ 85점 $)
+ 정말 놀랍게도, 단 3번만 움직여봐도 5개의 연속한 간선에 대한 정보를 알 수 있고, 단 5개의 연속한 숫자들에 대한 정보만 알고 있어도 그것이 0 1 0 0 1 1의 부분수열인지, 혹은 뒤집어야 하는지를 알 수 있게 된다. 해당 내용을 구현하면 역주행 횟수는 많아야 3회이기 때문에, 최단거리와 많아야 6회의 차이가 나게 된다.
