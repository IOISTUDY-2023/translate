# Stray Cat(Joisc 2020)
# 문제
+ Anthony는 JOI 도시에 사는 개미이다. JOI 도시에는 N개의 도시가 있으며, 각 도시에는 0부터 $N-1$이 적혀있다. Anthony는 0번 도시에 살고 있다. 도로는 총 M개가 있으며, 각 도로에는 0부터 $M-1$ 까지의 수가 쓰여있다. i번째 도로 $(0 \le i \le M-1)$ 는 $U_i$와 $V_i$를 이으며, 양방향으로 이동할 수 있다. 다른 도로는 서로 다른 쌍의 도시를 잇는다. 또한, 어떤 도시에서 시작해도 몇 개의 도로를 사용해서 다른 임의의 도시로 이동 가능하다.
+ Catherine은 Anthony의 친구이다. 그녀는 JOI 도시를 방문할 계획을 세우고 있지만, 그녀는 도시의 도로에 대한 정보를 몰라서 종종 방황한다. Anthony는 사전에 도로에 표시를 하기로 결정했다. 표시에는 총 A가지가 있으며, 이들은 각각 0부터 $A-1$까지 번호가 부여되어 있다.
+ 이제, Catherine은 JOI 도시에 도착했다. 그가 0번 도시가 아닌 다른 도시에 도착했을 때, 그는 다음과 같은 시행을 한다:
각 타입의 표시들에 대해, 그녀는 자신과 인접한 도로중에서 각 타입들이 총 몇 번 등장했는지 셀 수 있다. 단, 만약 해당 도시에 도달하기 바로 직전에 통과한 도로가 있다면 그 도로는 세지 않는다.
+ 이후, 그녀는 지날 도로를 선택한다. 중요한 사실은 그녀가 마지막으로 지난 도로를 제외하면, 그녀는 오직 도로를 표시로만 구분할 수 있다는 점이다. 도로를 적절히 결정해서, 그녀는 너무 많은 시간을 소비하지 않고 0번 도시에 도달하고자 한다. 조금 더 정확하게, 그녀가 처음 시작한 위치에서 0번 도시까지의 최단거리를 $d$라고 하면, 그녀는 도시를 최대 $d+B$번 선택 가능하다.
+ 도시에 대한 정보가 주어졌을 때 도로에 표시를 남기는 Anthony의 전략을 구현한 프로그램을 작성하고, 도시를 선택하는 Catherine의 전략을 구현한 프로그램을 작성하라.
# 구현
첫 번째 파일은 Anthony.cpp이다. Anthony의 전략을 구현하고 다음 기능을 구현해야 한다. 프로그램에는 Anthony.h가 포함되어야 한다.
+ std::vector Mark(int N, int M, int A, int B, std::vector U, std::vector V)
+ 이 함수는 실행 초반에 정확히 한 번 실행된다.
+ N은 도시 N의 수이다.
+ M은 도로 M의 수이다.
+ A는 마크 A의 유형 수이다.
+ B는 Catherine이 도로를 선택할 수 있는 횟수에 대한 여백이다.
+ U와 V는 길이 M의 배열이다. 여기서 U[i]와 V[i]는 도로 i로 연결된 마을 $U_i$와 $V_i$이다 $(0 ≤ i ≤ M − 1)$.
+ 반환 값 x는 길이 M의 배열이어야 한다. 길이가 M과 다른 경우 틀렸습니다[1]을 받는다. 값 x[i](0 ≤ i ≤ M − 1)는 도로 i에 표시된 표시를 나타낸다. 부등식 $0 ≤ x[i] ≤ A − 1$이 충족되어야 한다. $0 ≤ x[i] ≤ A − 1$이 만족되지 않으면 틀렸습니다[2]를 받는다.   
<br/>두 번째 파일은 Catherine.cpp이다. Catherine의 전략을 구현하고 다음 기능을 구현해야 한다. 프로그램에는 Catherine.h가 포함되어야 한다.
+ void Init(int A, int B)
+ 다음 함수는 실행 초반에 정확히 한 번 실행된다.
+ A는 표시의 가짓수이며, B는 Catherine이 고를 수 있는 도로 개수의 여유분이다.
+ int Move(std::vector y)
+ 이 함수는 Catherine이 0번 도시가 아닌 다른 도시에 도착할 때마다 호출된다.
+ y는 길이 A의 배열이며, y[j]는 그녀가 마지막으로 통과한 도로를 제외하고(존재한다면) $(0 ≤ j ≤ A − 1)$ 표시가 j인, 그녀가 현재 위치한 도시와 인접한 도로의 개수이다.
+ 반환 값 z는 $−1 ≤ z ≤ A − 1$을 만족해야 한다. $−1 ≤ z ≤ A − 1$을 만족하지 않으면 틀렸습니다[3]을 받는다. $z = -1$이면 마지막으로 지나갔던 도로를 선택하여 되돌아간다. $0 ≤ z ≤ A − 1$이면 표시가 z인 임의의 도로를 선택한다. Move 함수가 처음 호출될 때 $z = -1$이면 틀렸습니다[4]를 받는다. $0 ≤ z ≤ A−1$이고 $y[z] = 0$이면 틀렸습니다[5]를 받는다.   
<br/> 만약 캐서린이 그녀가 마지막으로 지난 도로가 아는 도로를 고른다면, 그 도로는 해당 표시가 존재하는 임의의 도로중 하나가 될 것이다. 이것이 꼭 랜덤하지는 않다는 점에 주의하라.   
<br/> 만약 캐서린이 도로를 $d+B$번 선택해서 0번 도시에 도달하지 못했다면, 틀렸습니다[6]을 받는다.
+ ## Subtask 1,3. ($ 4점 $)
+ 주어지는 그래프가 트리 구조이며, $A=3$인 경우이다. 
+ Anthony는 0번 정점을 루트 노드로 하여, 각 자식 노드들의 정점의 깊이를 계산한다. 이후, 0번 정점을 제외한 정점 $X$ 과 그 부모노드를 잇는 간선에 $dep(X)%3$을 적는다.
+ Catherine이 어떤 정점 $X$에 있었다고 하자. 두 가지 경우의 수가 존재한다.
+ 1. $X$와 연결된 간선의 종류가 정확히 하나 존재하는 경우: 이 경우 $X$가 트리의 리프임은 자명하기 때문에, 위로 올라가기 위해 그 간선을 선택하면 된다.
+ 2. $X$와 연결된 간선의 종류가 정확히 2개 존재하는 경우: 반드시 어떤 0~2 사이의 수 $k$에 대해서, $X$와 연결된 간선의 종류는 $k$, $(k+1)%3$ 둘임을 알 수 있다. 또한, 간선에 적힌 것은 자식 노드의 깊이이므로, 무조건 깊이가 더 작은 정점에 의해서 칠해졌을 $k$가 적힌 간선쪽으로 올라가면 된다는 사실을 알 수 있다.
+ ## Subtask 1,2. ($ 4점 $)
+ 그래프가 주어지며, $A=4$이다.
+ Subtask 1,3을 해결한 것과 유사한 논리를 사용할 것이다. 우선, Anthony는 0번 정점을 기준으로 bfs spanning tree를 찾아낸다. 이후, bfs spanning tree에 속하지 않은 모든 간선들에 3을 적고, bfs spanning tree에 대해서는 Subtask 1,3에서 진행한 행동을 동일하게 적용한다. 이렇게 bfs를 통해 그래프를 만들 경우, 무조건 어떤 정점과 루트 사이의 거리가 최소가 됨은 잘 알려져 있다.
+ Catherine은 단순히 3번 간선을 완벽히 무시하고 진행하면 된다.
+ ## Subtask 1,2,3,4. ($ 15점 $)
+ 그래프가 주어지며, $A=3$이다.
+ Subtask 1,2에서 사용하지 않은 간선을 더 잘 색칠할수는 없을까? 우선, bfs spanning tree에 대해서 다음과 같은 성질을 알아야 한다:
+ 임의의 간선이 연결하는 두 정점은 bfs spanning tree 내에서 깊이 차이가 2 이상일 수 없다. 만약 1을 초과하는 차이가 난다면, 그 간선이 bfs spanning tree를 이루는 데에 사용되지 않음이 모순이기 때문이다.
+ Anthony가 Subtask 1,2에서 bfs spanning tree에 속하지 않는 어떤 간선을 색칠하려 한다고 하고, 그 간선이 잇는 정점이 $X$, $Y$라고 하자. 일반성을 잃지 않고 $dep(X)<=dep(Y)$라고 할 때, 해당 간선에는 $dep(X)(mod 3)$을 적는다.
+ Catherine는 Subtask 1,3의 전략을 동일하게 적용하면 된다. 이것이 가능한 이유는 한 정점을 잇는 간선의 종류가 많아야 2개이며, 그중 하나는 반드시 자신보다 깊이가 얕은 정점과 연결되어있기 때문이다.
+ ## Subtask 5. ($ 5점 $)
+ 주어지는 그래프가 트리 구조이며, $A=2$이며, $B=2N$인 경우이다.
+ Subtask 1,3에서 했던 것과 유사하게, Anthony는 0번 정점을 기준으로 각 정점의 깊이를 계산한 다음, 간선이 잇는 더 깊은 정점의 깊이를 2로 나눈 나머지를 적는다.
+ Catherine의 첫 위치를 $X$라고 하자. Catherine의 전략은 경우에 따라 다음과 같이 나타난다:
+ 1. $X$와 연결된 간선의 종류가 1개일 때. 이 경우에는 $X$가 리프노드임을 확신할 수 있기 때문에 자신과 연결된 간선은 반드시 루트노드와 가까워지는 방향이며, 다음으로 도착하는 모든 정점들에 대해서도 어떤 간선이 부모노드로 가는 간선인지를 알기 때문에 이 시점부터는 무조건 해결이 가능하다.
+ 2. 그 외의 경우. Catherine이 가지고 있는 정보는 $X$가 리프가 아니라는 정보 뿐이다. 이 경우, 아무 숫자의 간선부터 탐색을 진행하면서 다음 정점으로 넘어갈 때마다 선택할 간선의 종류를 바꿔준다. 이렇게 진행할 경우 루트 노드에 도달하거나, 혹은 리프에 도달하게 된다. 루트 노드에 도달한다면 문제가 해결된 것이고, 리프 노드에 도달한다면 1번 케이스로 돌아가 해결하면 된다.
+ 최악의 경우는 리프노드에 도달한 다음 루트 노드로 가는 것인데, 이 경우 이동횟수가 $B$를 넘을 일은 절대 없기 때문에 가능하다.
+ ## Subtask 5,6. ($ 76점 $)
+ 주어지는 그래프가 트리 구조이며, $A=2$이며, $B=12$인 경우이다.
+ 직관적으로 생각해보면 상수번 만큼 이동하다가, 자신의 이동이 루트와 멀어진다는 것을 판별하고 바로 역행을 하거나 자신이 올바른 방향으로 가고 있다는 확신을 얻어야만 문제가 해결됨을 알 수 있다.
+ 그러나, 우리가 기존에 간선을 색칠할 때 사용했던 0 1 0 1 0 1은 이러한 측면에서 어떤 정보도 제공하지 않는다.
+ 이런 대칭성을 제거할 수 있으면서, 가능한 한 반복이 짧은 이진 수열에는 어떤 것이 있을까?
+ 0 1 0 0 1 1 0 1 0 0 1 1....의 경우에는 판별이 가능하다(즉, 뒤집으면 다른 수열이 나온다.). 예외적으로, 만약 자식 노드가 2개 이상인 정점에 "루트 노드와 가까워지는 방향으로" 도달하게 될 때에는 무조건 루트 노드와 가까워지는 쪽과는 다른 숫자로 자식들을 연결하는 간선을 채우자.
+ 즉, Anthony가 해야 할 일은 다음과 같다:
+ dfs를 진행하면서, 현재 탐색중인 정점을 $X$라고 하고, $X$와 그 부모 정점을 잇는 간선에 적힌 수를 $k$라고 하자.
+ 1. $X$의 자식이 2개 이상일 경우: $X$의 자식노드를 잇는 간선을 $1-k$로 칠한다.
+ 2. $X$의 자식이 1개인 경우: 그 뒤로 쭉 각 정점들의 노드가 1개인 경우를 생각하자. $X$의 위에 칠해진 $k$와 모순되지 않게, 0 1 0 0 1 1을 연속적으로 칠한다. 이를 구현하는 방법은, 자식이 1개인 각 정점들에 $0~5$까지의 인덱스를 부여한 채로 dfs를 진행하는 것이다.
+ Catherine은 처음으로 움직일 간선의 숫자를 정한 후, 계속 움직인다. 만약 도중에 어떤 정점과 연결된 간선의 종류가 2개가 나온다면, 현재까지 잘 진행하고 있음을 의미하기 때문에 이 시점부터는 탐색할 간선의 숫자를 계속 바꿔가면서 탐색만 해도 루트 노드에 도달 가능하다. 반대로 총 간선의 개수는 3 이상인데 간선의 종류가 하나밖에 없다면 현재 Catherine이 역주행을 하고 있음을 의미하기 때문에, 바로 반대 방향으로 이동해서 루트로 이동 가능하다.
+ 만약 자식이 1개 이하인 정점들만으로 총 6회 움직였다고 생각하자. 이 경우 현재까지 지나온 간선들에 적힌 수의 배열을 알 수 있고, 이것이 0 1 0 0 1 1의 일부인지, 혹은 이를 뒤집은 수열의 일부인지를 판별해서 자신이 옳은 방향으로 가고 있는지, 혹은 역주행을 하고 있는지 알아낼 수 있다.
+ 역주행을 할 수 있는 횟수는 많아야 6회이므로, 많아야 12번 초과로 움직이게 된다.
+ ## Subtask 5,6,7. ($ 85점 $)
+ 정말 놀랍게도, 단 3번만 움직여봐도 5개의 연속한 간선에 대한 정보를 알 수 있고, 단 5개의 연속한 숫자들에 대한 정보만 알고 있어도 그것이 0 1 0 0 1 1의 부분수열인지, 혹은 뒤집어야 하는지를 알 수 있게 된다. 해당 내용을 구현하면 역주행 횟수는 많아야 3회이기 때문에, 최단거리와 많아야 6회의 차이가 나게 된다.
