# Bitaro's Party(joisc 2018)
# 문제
높은 순서대로 1에서 N까지 번호가 매겨진 N개의 비버 마을이 있습니다. 두 도시의 높이는 같지 않습니다.    
서로 다른 두 마을을 단방향으로 연결하는 M 운하가 있습니다. i번째 운하 $(1 ≤ i ≤ M)$는 $S_i$ 마을에서 $E_i$ 마을로 흐릅니다.   
이 운하는 높은 마을에서 낮은 마을로 흐릅니다. 운하의 흐름을 거슬러 움직일 수 없습니다.   
   
비버인 비타로는 N명의 친구가 있고 그 중 한 명은 N개의 마을에 살고 있습니다.   
   
Bitaro는 친구들을 초대하여 Q번 파티를 열 예정입니다. j번째 $(1 ≤ j ≤ Q)$ 파티는 $Y_j$명의 친구들이 너무 바빠 참석할 수 없는 것으로 알려져 있습니다.   
j번째 파티는 $T_j$ 마을에서 열리므로 운하만을 통해서 자신의 마을에서 $T_j$번째 마을로 갈 수 없는 그의 친구들도 참석할 수 없습니다. 그렇지 않은 친구들은 파티에 옵니다.   
   
각 친구들은 운하를 통해 파티가 열리는 마을로 옵니다. 그들이 취할 수 있는 길은 여러 가지가 있을 수 있습니다.   
하지만 Bitaro의 친구들은 운하를 좋아하기 때문에 운하가 가장 많은 길 중 하나를 선택해야 합니다.   
   
Bitaro는 가장 많은 수의 운하를 사용하는 친구가 몇 개의 운하를 사용하는지 궁금해합니다.   
   
파티가 열리는 마을의 인덱스와 Q 파티에 바쁜 친구 목록이 주어지면 가장 많은 수의 운하를 사용하는 참석자가 몇 개의 운하를 사용하는지 계산하는 프로그램을 작성하십시오.   
# 입력
표준 입력에서 다음 데이터를 읽습니다.   
   
입력의 첫 번째 줄에는 세 개의 공백으로 구분된 정수 N, M, Q가 포함됩니다. 이는 비버의 N 마을과 M 운하 및 Q 파티 Bitaro가 있음을 의미합니다.   
다음 M 라인의 i 번째 라인 $(1 ≤ i ≤ M)$에는 공백으로 구분된 두 개의 정수 $S_i$ 및 $E_i$가 포함됩니다. 
이것은 운하가 $S_i$에서 $E_i$로 단방향으로 흐른다는 것을 의미합니다.   
다음 Q 행의 j번째 행 $(1 ≤ j ≤ Q)$에는 공백으로 구분된 두 정수 $T_j$ , $Y_j$ 및 $Y_j$ 공백으로 구분된 정수 $C_{j,1}, C_{j,2}, ..., C_{j,Y_j}$가 포함됩니다.    
이것은 j번째 파티가 $T_j$ 마을에서 열리고 $C_{j,1}, C_{j,2}, ...,C_{j,Y_j}$ 마을에 사는 친구들이 바쁘다는 것을 의미합니다.   
# 출력
Q개의 줄에 정수를 한 개씩 출력하십시오.   
j번째 줄 $(1 ≤ j ≤ Q)$에는 j번째 파티에서 가장 많은 수의 운하를 사용하는 참석자가 사용하는 운하의 수를 출력해야 합니다. j번째 파티에 아무도 참석할 수 없으면 j번째 줄에 -1을 출력합니다.
# 제한
$1 ≤ N ≤ 100 000.$   
$0 ≤ M ≤ 200 000.$   
$1 ≤ Q ≤ 100 000.$   
$1 ≤ S_i < E_i ≤ N (1 ≤ i ≤ M).$   
$(S_i , E_i) , (S_j , E_j) (1 ≤ i < j ≤ M).$   
$1 ≤ T_j ≤ N (1 ≤ j ≤ Q).$   
$0 ≤ Y_j ≤ N (1 ≤ j ≤ Q).$   
$1 ≤ C_{j,1} < C_{j,2} < · · · < C_{j,Y_j} ≤ N (1 ≤ j ≤ Q).$   
$Y_1 + Y_2 + · · · + Y_Q ≤ 100 000．$   
# 서브태스크
|번호|배점|제한|
|---|---|---|
|1|7|$N \le 1000, M \le 2000, Q=1$|
|2|7|$Q=1$|
|3|86|추가 제약조건이 없음|
+ ## Subtask 1,2. ( $14점$)
모든 쿼리가 정확히 하나의 정점에 대해서만 진행되는 경우의 dp 입니다. 각 정점들의 최대 운하의 수를 dp값으로 들고 있는 상황을 생각해봅시다. 어차피 DAG이기 때문에 어떤 노드에서 필요한 운하의 수를 재귀적으로 파고들면 항상 dp를 적절히 계산할 수 있음을 알 수 있습니다. 따라서 주어진 상황에서 최대 운하수를 전부 계산할 수 있고, 따라서 문제를 해결할 수 있습니다.
+ ## Subtask 3. ( $86점$)
우선, 만약 $Y_i$가 굉장히 크다면, 이때는 단순히 subtask 1,2의 풀이를 바로 적용해서 $O(n+m)$정도에 문제를 해결할 수 있습니다. $Y_i$가 굉장히 큰 쿼리들에 대해 잠시 생각해보면, 그러한 쿼리들은 그렇게 많지 않다는 사실을 알 수 있습니다. 만약 $t \le Y_i$일때 $Y_i$가 "굉장히 크다"라고 한다면, 그러한 쿼리의 개수는 $Q/t$를 절대 넘을 수 없고, 따라서 이 종류의 쿼리들을 처리하는데에 드는 시간은 $O((n+m)*Q/t)$가 됩니다.   
 이제 남은 것은 $Y_i$가 충분히 작은 쿼리들입니다. 여기에서 해야하는 관찰은, 파티가 주최되는 정점으로 갈 수 있는 최대 경로의 길이를 구하는 문제는, 그래프의 방향을 완벽히 뒤집은 다음 파티가 주최되는 정점에서 도달할 수 있는 모든 정점들에 대해 그 경로의 최댓값을 구하는 문제로 바꿀 수 있다는 사실입니다. 물론, subtask 1,2의 풀이처럼 최댓값만 저장해둔다면 최댓값이 되는 정점이 바쁜 정점일 가능성이 있기 때문에 통하지 않음을 알 수 있습니다.   
 그렇다면, 만약 하나의 정점에서 갈 수 있는 정점들을 경로가 긴 순으로 $t+1$개 들고 있는 상황이라면 어떨까요? 무조건 DAG이기 때문에 자식노드들로부터 병합을 하는 것도 가능하고, 설령 해당 정점에서 알아낸 $t+1$개의 정점들중 $t$개가 다르다고 하더라도, 남아있는 나머지 하나의 정점이 최대 길이라는 사실을 자명하게 알 수 있습니다. 어떤 노드에서 두 자식노드를 융합하는데에 걸리는 시간복잡도는 두 수열을 merge하는 아이디어처럼 구현한다면 $O(t)$가 되고, 간선은 m개이기 때문에 총 시간복잡도는 $O(t(m+n))$정도가 됩니다. 하나의 쿼리를 처리하기 위해서는 역시 적절한 처리를 통해 어떤 정점이 들고 있는 $t+1$개의 정점들중 제외되는 것들을 전부 빼낸 뒤 그중 최댓값을 찾으면 되는데, 이 또한 $O(t)$에 해결할 수 있습니다.   
 결과적으로, 전체 문제를 $(O(t(m+n)+(m+n)*Q/t))$만에 해결할 수 있는데, 이는 $t=sqrt(Q)$로 둘 경우 $O((m+n)sqrt(Q))$가 되어 문제를 해결하기에 충분해집니다.
