# Library(joisc 2018)
# 문제
수백년이 지난 후, JOI 도시는 폐허가 되었습니다. 탐험가인 IOI쨩은 도서관이 지어졌던 곳을 탐험하고 있습니다.
탐험의 결과, 다음과 같은 사실이 알려졌습니다:
+ JOI 도시의 도서관의 선반에는 N개의 책이 있었습니다. N개의 책들은 왼쪽에서 오른쪽으로 배열되어 있었습니다.
+ N개의 책들은 1부터 N까지 번호가 매겨져있었습니다. 그러나 그것이 선반에서의 번호와 일치하지는 않습니다.
+ 한 번의 연산을 통해, 선반에서 연속한 몇 개의 책들을 고를 수 있습니다.
 불행히도, IOI쨩은 도서관의 고서들을 찾을 수 없었습니다. 그러나 그녀는 도서관의 선반에서 일어났던
연산들을 담당했던 기계를 발견했습니다. 만약 우리가 몇 개의 책들의 번호를 기계에 집어넣으면,
이 기계는 선반에서 책을 가져오는데 필요한 연산의 최소 횟수를 반환합니다.

IOI쨩은 기계에 몇개의 질문을 함으로써 선반의 책들의 순서를 알고자 합니다. 그러나,
만약 선반에 대해 모든 책들의 순서가 반대여도 구분이 불가능하기 때문에, 그녀가 찾는 책의 순서는
좌우를 따지지 않습니다.

기계가 낡았기 때문에, 많아야 20000번의 질문을 할 수 있습니다.

기계에 많아야 20000번의 질문을 해서 책의 순서를 알아내는 프로그램을 작성하십시오. 좌우구분을 맞을
필요는 없습니다.
# 구현
하나의 파일을 제출해야 합니다.

파일의 이름은 library.cpp입니다. 다음 기능을 구현해야 합니다.
프로그램에는 library.h가 포함되어야 합니다.

void Solve(int N)
각 테스트 사례에 대해 이 함수는 한 번 호출됩니다.
매개변수 N은 책장에 있는 책의 수 N입니다.
프로그램은 다음 함수를 호출할 수 있습니다.

int Query(const std::vector<int>& M)
​​​​​​​하나 이상의 책이 번호로 지정된 경우 이 함수는 책장에서 해당 책만 가져오는 데 필요한
최소 작업 수를 반환합니다.
책장에서 가져온 책은 크기 N의 벡터인 매개변수 M으로 지정됩니다.
각 $i(1 ≤ i ≤ N)$에 대해 M[i-1] = 0이면 책 i는 책장에서 가져오지 않습니다.
M[i-1] = 1이면 책 i를 책장에서 꺼냅니다. M의 크기가 N과 다르면 프로그램은 틀렸습니다[1]으로
간주됩니다. 각 i에 대해 M[i-1]은 0 또는 1과 같아야 합니다. M[i-1] = 1인 $i(1 ≤ i ≤ N)$가 
하나 이상 존재해야 합니다. 이 둘 중 하나라도 조건이 만족되지 않으면 
프로그램은 틀렸습니다[2]으로 간주됩니다. Query 함수가 20,000회 이상 호출되면 프로그램은
틀렸습니다[3]으로 간주됩니다.
void Answer(const std::vector<int>& res)
​​​​​​​이 ​​기능을 사용하면 프로그램이 책장에 있는 책의 순서에 응답합니다. 책이 왼쪽에서 오른쪽으로
놓였는지, 오른쪽에서 왼쪽으로 놓여졌는지 지정할 필요는 없습니다.
res 매개변수는 크기 N의 벡터입니다. 책장에 있는 책의 순서를 설명합니다. 각 $i(1 ≤ i ≤ N)$에
대해 책장의 왼쪽에서 i번째 책의 번호는 res[i-1]입니다. res의 크기가 N과 다른 경우 프로그램은
틀렸습니다[4]으로 간주됩니다. res[i-1]은 1과 N 사이의 정수여야 합니다. 이 조건이 만족되지 않으면
프로그램은 틀렸습니다[5]으로 간주됩니다. 또한 정수 res[0], res[1],. . ., res[N-1]은 서로
달라야 합니다. 이 조건이 만족되지 않으면 프로그램은 틀렸습니다[6]으로 간주됩니다.
Solve 함수가 종료되었을 때 Answer 함수 호출 횟수가 1회와 다를 경우 해당 프로그램은
틀렸습니다[7]로 간주됩니다.

Solve 함수에서 지정한 책의 순서가 책장에 있는 책의 순서와 다를 경우 프로그램은
틀렸습니다[8]으로 간주됩니다. 책이 왼쪽에서 오른쪽으로 놓였는지, 오른쪽에서 왼쪽으로 놓여졌는지
지정할 필요는 없습니다.
 
# 제한
$1 ≤ N ≤ 1 000.$   
$1 ≤ A_i ≤ N(1\le i \le N).$   
$A_i\neq A_j(1\le i\lt j\le N).$   
## 예제
다음은 샘플 그레이더에 대한 샘플 입력과 그에 대응되는 함수의 호출입니다.

이 문제에서, 책들이 오른쪽에서 왼쪽으로 배치되었는지, 혹은 반대인지를 구분할 필요는 없습니다.
따라서 당신의 프로그램은 매개변수가 뒤집힌 Answer({1,3,5,2,4})를 호출해도 정점으로 간주됩니다.
# 서브태스크
|번호|배점|제한|
|---|---|---|
|1|19|$N \le 200$|
|2|81|추가 제약조건이 없습니다.|
+ ## Subtask 1. ( $19점$)
굉장히 다양한 풀이가 있을 수 있습니다. 한 가지 생각해볼 수 있는 단순한 방법은, 모든 두 책의 쌍에
대해서 쿼리를 날려보는 것입니다. 그렇게 하면 각 책들의 연결성을 알 수 있고, 따라서 좌우반전을
제외하고는 답을 알아낼 수 있습니다.
+ ## Subtask 2. ( $100점$)
이번에는 해당 방식이 별로 빠르지 않다는 사실을 알 수 있습니다. 
